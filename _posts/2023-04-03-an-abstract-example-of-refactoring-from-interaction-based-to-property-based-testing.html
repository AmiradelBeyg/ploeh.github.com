---
layout: post
title: "An abstract example of refactoring from interaction-based to property-based testing"
description: "A C# example with xUnit.net and CsCheck"
date: 2023-04-03 6:02 UTC
tags: [Unit Testing, Property-based Testing]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        This is the first comprehensive example that accompanies the article <a href="/2023/02/13/epistemology-of-interaction-testing">Epistemology of interaction testing</a>. In that article, I argue that in a code base that leans toward functional programming (FP), property-based testing is a better fit than interaction-based testing. In this example, I will show how to refactor simple interaction-based tests into a property-based tests.
    </p>
    <p>
        This small article series was prompted by an email from Sergei Rogovtsev, who was kind enough to furnish <a href="https://github.com/srogovtsev/mocks-in-tests">example code</a>. I'll use his code as a starting point for this example, so I've <a href="https://github.com/ploeh/mocks-in-tests">forked the repository</a>. If you want to follow along, all my work is in a branch called <em>no-mocks</em>. That branch simply continues off the <em>master</em> branch.
    </p>
    <h3 id="5fe789d2b85b449fa2677bbcbf095bfc">
        Interaction-based testing <a href="#5fe789d2b85b449fa2677bbcbf095bfc">#</a>
    </h3>
    <p>
        Sergei Rogovtsev writes:
    </p>
    <blockquote>
        <p>
            "A major thing to point out here is that I'm not following TDD here not by my own choice, but because my original question arose in a context of a legacy system devoid of tests, so I choose to present it to you in the same way. I imagine that working from tests would avoid a lot of questions."
        </p>
    </blockquote>
    <p>
        Even when using test-driven development (TDD), most code bases I've seen make use of <a href="http://xunitpatterns.com/Test%20Stub.html">Stubs</a> and <a href="http://xunitpatterns.com/Mock%20Object.html">Mocks</a> (or, rather, <a href="http://xunitpatterns.com/Test%20Spy.html">Spies</a>). In an object-oriented context this can make much sense. After all, a catch phrase of object-oriented programming is <em>tell, don't ask</em>.
    </p>
    <p>
        If you base API design on that principle, you're modelling side effects, and it makes sense that tests use Spies to verify those side effects. The book <a href="/ref/goos">Growing Object-Oriented Software, Guided by Tests</a> is a good example of this approach. Thus, even if you follow established good TDD practice, you could easily arrive at a code base reminiscent of Sergei Rogovtsev's example. I've written plenty of such code bases myself.
    </p>
    <p>
        Sergei Rogovtsev then extracts a couple of components, leaving him with a <code>Controller</code> class looking like this:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Complete</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>&nbsp;=&nbsp;_repository.GetState(state);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">try</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(_stateValidator.Validate(code,&nbsp;knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;_renderer.Success(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;_renderer.Failure(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">catch</span>&nbsp;(Exception&nbsp;<span style="font-weight:bold;color:#1f377f;">e</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;_renderer.Error(knownState,&nbsp;e);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        This code snippet doesn't show the entire class, but only its solitary action method. Keep in mind that the entire repository is available on GitHub if you want to see the surrounding code.
    </p>
    <p>
        The <code>Complete</code> method orchestrates three injected dependencies: <code>_repository</code>, <code>_stateValidator</code>, and <code>_renderer</code>. The question that Sergei Rogovtsev asks is how to test this method. You may think that it's so simple that you don't need to test it, but keep in mind that this is a <a href="https://en.wikipedia.org/wiki/Minimal_reproducible_example">minimal and self-contained example</a> that stands in for something more complicated.
    </p>
    <p>
        The method has a cyclomatic complexity of <em>3</em>, so <a href="/2019/12/09/put-cyclomatic-complexity-to-good-use">you need at least three test cases</a>. That's also what Sergei Rogovtsev's code contains. I'll show each test case in turn, while I refactor them.
    </p>
    <p>
        The overall question is still this: Both <code>IStateValidator</code> and <code>IRenderer</code> interfaces have only a single production implementation, and in both cases the implementations are <a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>. If interaction-based testing is suboptimal, is there a better way to test this code?
    </p>
    <p>
        As I outlined in <a href="/2023/02/13/epistemology-of-interaction-testing">the introductory article</a>, I consider property-based testing a good alternative. In the following, I'll refactor the tests. Since the tests already use <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a>, most of the preliminary work can be done without choosing a property-based testing framework. I'll postpone that decision until I need it.
    </p>
    <h3 id="ca095000df004ef9b7cb7c022071f76b">
        State validator <a href="#ca095000df004ef9b7cb7c022071f76b">#</a>
    </h3>
    <p>
        The <code>IStateValidator</code> interface has a single implementation:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">StateValidator</span>&nbsp;:&nbsp;IStateValidator
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Validate</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;(<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;code&nbsp;==&nbsp;knownState.expectedCode;
}</pre>
    </p>
    <p>
        The <code>Validate</code> method is a pure function, so it's completely deterministic. It means that you don't have to hide it behind an interface and replace it with a <a href="https://martinfowler.com/bliki/TestDouble.html">Test Double</a> in order to control it. Rather, just feed it proper data. Still, that's not what the interaction-based tests do:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;_stateValidator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">validator</span>&nbsp;=&gt;&nbsp;validator.Validate(code,&nbsp;knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(<span style="color:blue;">true</span>);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Success(knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
 
&nbsp;&nbsp;&nbsp;&nbsp;_target
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        These tests use AutoFixture, which will make it a bit easier to refactor them to properties. It also makes the test a bit more abstract, since you don't get to see concrete test data. In short, the <code>[AutoData]</code> attribute will generate a random <code>state</code> string, a random <code>code</code> string, and so on. If you want to see an example with concrete test data, the next article shows that variation.
    </p>
    <p>
        The test uses <a href="https://github.com/moq/moq4">Moq</a> to control the behaviour of the Test Doubles. It states that the <code>Validate</code> method will return <code>true</code> when called with certain arguments. This is possible because you can redefine its behaviour, but as far as executable specifications go, this test doesn't reflect reality. There's only one <code>Validate</code> implementation, and it doesn't behave like that. Rather, it'll return <code>true</code> when <code>code</code> is equal to <code>knownState.expectedCode</code>. The test poorly communicates that behaviour.
    </p>
    <p>
        Even before I replace AutoFixture with CsCheck, I'll prepare the test by making it more honest. I'll replace the <code>code</code> parameter with a <a href="http://xunitpatterns.com/Derived%20Value.html">Derived Value</a>:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;The&nbsp;rest&nbsp;of&nbsp;the&nbsp;test...</span></pre>
    </p>
    <p>
        I've removed the <code>code</code> parameter to replace it with a variable derived from <code>knownState</code>. Notice how this <em>documents</em> the overall behaviour of the (sub-)system.
    </p>
    <p>
        This also means that I can now replace the <code>IStateValidator</code> Test Double with the real, pure implementation:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Success(knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(_repository,&nbsp;<span style="color:blue;">new</span>&nbsp;StateValidator(),&nbsp;_renderer.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        I give the <code>Failure</code> test case the same treatment:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Failure</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode&nbsp;+&nbsp;<span style="color:#a31515;">&quot;1&quot;</span>;&nbsp;<span style="color:green;">//&nbsp;Any&nbsp;extra&nbsp;string&nbsp;will&nbsp;do</span>
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Failure(knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(_repository,&nbsp;<span style="color:blue;">new</span>&nbsp;StateValidator(),&nbsp;_renderer.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        The third test case is a bit more interesting.
    </p>
    <h3 id="aa150cf1b817416ea49e30cdc8b27ac7">
        An impossible case <a href="#aa150cf1b817416ea49e30cdc8b27ac7">#</a>
    </h3>
    <p>
        Before I make any changes to it, the third test case is this:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Error</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,
&nbsp;&nbsp;&nbsp;&nbsp;Exception&nbsp;<span style="font-weight:bold;color:#1f377f;">e</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;_stateValidator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">validator</span>&nbsp;=&gt;&nbsp;validator.Validate(code,&nbsp;knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Throws(e);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Error(knownState,&nbsp;e))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
 
&nbsp;&nbsp;&nbsp;&nbsp;_target
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        This test case verifies the behaviour of the <code>Controller</code> class when the <code>Validate</code> method throws an exception. If we want to instead use the real, pure implementation, how can we get it to throw an exception? Consider it again:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Validate</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;(<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;code&nbsp;==&nbsp;knownState.expectedCode;</pre>
    </p>
    <p>
        As far as I can tell, there's no way to get this method to throw an exception. You might suggest passing <code>null</code> as the <code>knownState</code> parameter, but that's not possible. This is a new version of C# and the <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/nullable-reference-types">nullable reference types</a> feature is turned on. I spent some fifteen minutes trying to convince the compiler to pass a <code>null</code> argument in place of <code>knownState</code>, but I couldn't make it work in a unit test.
    </p>
    <p>
        That's interesting. The <code>Error</code> test is exercising a code path that's impossible in production. Is it redundant?
    </p>
    <p>
        It might be, but here I think that it's more an artefact of the process. Sergei Rogovtsev has provided a minimal example, and as it sometimes happens, perhaps it's a bit too minimal. He did write, however, that he considered it essential for the example that the logic involved more that an Boolean <em>true/false</em> condition. In order to keep with the spirit of the example, then, I'm going to modify the <code>Validate</code> method so that it's also possible to make it throw an exception:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Validate</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;(<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState&nbsp;==&nbsp;<span style="color:blue;">default</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;ArgumentNullException(nameof(knownState));
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;code&nbsp;==&nbsp;knownState.expectedCode;
}</pre>
    </p>
    <p>
        The method now throws an exception if you pass it a <code>default</code> value for <code>knownState</code>. From an implementation standpoint, there's no reason to do this, so it's only for the sake of the example. You can now test how the <code>Controller</code> handles an exception:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Error</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;<span style="color:blue;">default</span>);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Error(<span style="color:blue;">default</span>,&nbsp;It.IsAny&lt;Exception&gt;()))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(_repository,&nbsp;<span style="color:blue;">new</span>&nbsp;StateValidator(),&nbsp;_renderer.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        The test no longer has a reference to the specific <code>Exception</code> object that <code>Validate</code> is going to throw, so instead it has to use Moq's <code>It.IsAny</code> API to configure the <code>_renderer</code>. This is, however, only an interim step, since it's now time to treat that dependency in the same way as the validator.
    </p>
    <h3 id="389a212d80a4445c99917cbd15b043eb">
        Renderer <a href="#389a212d80a4445c99917cbd15b043eb">#</a>
    </h3>
    <p>
        The <code>Renderer</code> class has three methods, and they are all pure functions:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Renderer</span>&nbsp;:&nbsp;IRenderer
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Success</span>((<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState.isMobile)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;{\&quot;success\&quot;:&nbsp;true,&nbsp;\&quot;redirect\&quot;:&nbsp;\&quot;&quot;</span>&nbsp;+&nbsp;knownState.redirect&nbsp;+&nbsp;<span style="color:#a31515;">&quot;\&quot;}&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;302&nbsp;Location:&nbsp;&quot;</span>&nbsp;+&nbsp;knownState.redirect;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Failure</span>((<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState.isMobile)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;{\&quot;success\&quot;:&nbsp;false,&nbsp;\&quot;redirect\&quot;:&nbsp;\&quot;login\&quot;}&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;302&nbsp;Location:&nbsp;login&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Error</span>((<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;Exception&nbsp;<span style="font-weight:bold;color:#1f377f;">e</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState.isMobile)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;{\&quot;error\&quot;:&nbsp;\&quot;&quot;</span>&nbsp;+&nbsp;e.Message&nbsp;+&nbsp;<span style="color:#a31515;">&quot;\&quot;}&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;500&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        Since all three methods are deterministic, automated tests can control their behaviour simply by passing in the appropriate arguments:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Renderer();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(_repository,&nbsp;renderer);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>&nbsp;=&nbsp;renderer.Success(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(expected);
}</pre>
    </p>
    <p>
        Instead of configuring an <code>IRenderer</code> Stub, the test can state the <code>expected</code> output: That the output is equal to the output that <code>renderer.Success</code> would return.
    </p>
    <p>
        Notice that the test doesn't <em>require</em> that the implementation calls <code>renderer.Success</code>. It only requires that the output is equal to the output that <code>renderer.Success</code> would return. Thus, it has less of an opinion about the implementation, which means that it's marginally less coupled to it.
    </p>
    <p>
        You might protest that the test now duplicates the implementation code. This is partially true, but no more than the previous incarnation of it. Before, the test used Moq to explicitly <em>require</em> that <code>renderer.Success</code> gets called. Now, there's still coupling, but this refactoring reduces it.
    </p>
    <p>
        As a side note, this may partially be an artefact of the process. Here I'm refactoring tests while keeping the implementation intact. Had I started with a property, perhaps the test would have turned out differently, and less coupled to the implementation. If you're interested in a successful exercise in using property-based TDD, you may find my article <a href="/2021/06/28/property-based-testing-is-not-the-same-as-partition-testing">Property-based testing is not the same as partition testing</a> interesting.
    </p>
    <h3 id="81bbcfc59f5c48df8ee15f9d1bad47cf">
        Simplification <a href="#81bbcfc59f5c48df8ee15f9d1bad47cf">#</a>
    </h3>
    <p>
        Once you've refactored the tests to use the pure functions as dependencies, you no longer need the interfaces. The interfaces <code>IStateValidator</code> and <code>IRenderer</code> only existed to support testing. Now that the tests no longer use the interfaces, you can delete them.
    </p>
    <p>
        Furthermore, once you've removed those interfaces, there's no reason for the classes to support instantiation. Instead, make them <code>static</code>:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">StateValidator</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">Validate</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState&nbsp;==&nbsp;<span style="color:blue;">default</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;ArgumentNullException(nameof(knownState));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;code&nbsp;==&nbsp;knownState.expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        You can do the same for the <code>Renderer</code> class.
    </p>
    <p>
        This doesn't change the overall <em>flow</em> of the <code>Controller</code> class' <code>Complete</code> method, although the implementation details have changed a bit:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Complete</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>&nbsp;=&nbsp;_repository.GetState(state);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">try</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(StateValidator.Validate(code,&nbsp;knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;Renderer.Success(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;Renderer.Failure(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">catch</span>&nbsp;(Exception&nbsp;<span style="font-weight:bold;color:#1f377f;">e</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;Renderer.Error(knownState,&nbsp;e);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        <code>StateValidator</code> and <code>Renderer</code> are no longer injected dependencies, but rather 'modules' that affords pure functions.
    </p>
    <p>
        Both the <code>Controller</code> class and the tests that cover it are simpler.
    </p>
    <h3 id="984cd44e8f6545ddafa673a411e188f1">
        Properties <a href="#984cd44e8f6545ddafa673a411e188f1">#</a>
    </h3>
    <p>
        So far I've been able to make all these changes without introducing a property-based testing framework. This was possible because the tests already used AutoFixture, which, while not a property-based testing framework, already strongly encourages you to write tests without literal test data.
    </p>
    <p>
        This makes it easy to make the final change to property-based testing. On the other hand, it's a bit unfortunate from a pedagogical perspective. This means that you didn't get to see how to refactor a 'traditional' unit test to a property. The next article in this series will plug that hole, as well as show a more realistic example.
    </p>
    <p>
        It's now time to pick a property-based testing framework. On .NET you have a few choices. Since this code base is C#, you may consider a framework written in C#. I'm not convinced that this is necessarily better, but it's a worthwhile experiment. Here I've used <a href="https://github.com/AnthonyLloyd/CsCheck">CsCheck</a>.
    </p>
    <p>
        Since the tests already used randomly generated test data, the conversion to CsCheck is relatively straightforward. I'm only going to show one of the tests. You can always find the rest of the code in the Git repository.
    </p>
    <p>
        <pre>[Fact]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:blue;">from</span>&nbsp;state&nbsp;<span style="color:blue;">in</span>&nbsp;Gen.String
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">from</span>&nbsp;expectedCode&nbsp;<span style="color:blue;">in</span>&nbsp;Gen.String
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">from</span>&nbsp;isMobile&nbsp;<span style="color:blue;">in</span>&nbsp;Gen.Bool
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;urls&nbsp;=&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:#a31515;">&quot;https://example.com&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;https://example.org&quot;</span>&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">from</span>&nbsp;redirect&nbsp;<span style="color:blue;">in</span>&nbsp;Gen.OneOfConst(urls).Select(<span style="font-weight:bold;color:#1f377f;">s</span>&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;Uri(s))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">select</span>&nbsp;(state,&nbsp;(expectedCode,&nbsp;isMobile,&nbsp;redirect)))
&nbsp;&nbsp;&nbsp;&nbsp;.Sample((<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)&nbsp;=&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">repository</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;RepositoryStub();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(repository);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>&nbsp;=&nbsp;Renderer.Success(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(expected);
&nbsp;&nbsp;&nbsp;&nbsp;});
}</pre>
    </p>
    <p>
        Compared to the AutoFixture version of the test, this looks more complicated. Part of it is that CsCheck (as far as I know) doesn't have the same <a href="https://www.nuget.org/packages/AutoFixture.Xunit2/">integration with xUnit.net that AutoFixture has</a>. That might be an issue that someone could address; after all, <a href="https://fscheck.github.io/FsCheck/RunningTests.html">FsCheck has framework integration</a>, to name an example.
    </p>
    <p>
        <a href="/2023/02/13/epistemology-of-interaction-testing">Test data generators are monads</a> so you typically leverage whatever syntactic sugar a language offers to simplify monadic composition. <a href="/2022/03/28/monads">In C# that syntactic sugar is query syntax</a>, which explains that initial <code>from</code> block.
    </p>
    <p>
        The test does look too top-heavy for my taste. An equivalent problem appears in the next article, where I also try to address it. In general, the better monad support a language offers, the more elegantly you can address this kind of problem. C# isn't really there yet, whereas languages like <a href="https://fsharp.org/">F#</a> and <a href="https://www.haskell.org/">Haskell</a> offer superior alternatives.
    </p>
    <h3 id="b0e7738d8b0440bba33caa470fd440fb">
        Conclusion <a href="#b0e7738d8b0440bba33caa470fd440fb">#</a>
    </h3>
    <p>
        In this article I've tried to demonstrate how property-based testing is a viable alternative to using Stubs and Mocks for verification of composition. You can try to sabotage the <code>Controller.Complete</code> method in the <em>no-mocks</em> branch and see that one or more properties will fail.
    </p>
    <p>
        While the example code base that I've used for this article has the strength of being small and self-contained, it also suffers from a few weaknesses. It's perhaps a bit too abstract to truly resonate. It also uses AutoFixture to generate test data, which already takes it halfway towards property-based testing. While that makes the refactoring easier, it also means that it may not fully demonstrate how to refactor an example-based test to a property. I'll try to address these shortcomings in the next article.
    </p>
    <p>
        <strong>Next:</strong> A restaurant example of refactoring from example-based to property-based testing.
    </p>

</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>

    <div class="comment" id="0510331b953a4c308c3b01a918d2b65c">
        <div class="comment-author"><a href="https://github.com/srogovtsev">Sergei Rogovtcev</a></div>
        <div class="comment-content">
            <p>First of all, thanks again for continuing to explore this matter. This was very enlightening, but in the end, I was left with is a sense of subtle wrongness, which is very hard to pin down, and even harder to tell apart between "this is actually not right for me" and "this is something new I'm not accustomed to".</p>

            <p>I suppose that my main question would center around difference between your tests for <code>IStateValidator</code> and <code>IRenderer</code>. Let's start with the latter:</p>

            <blockquote><p>Instead of configuring an <code>IRenderer</code> Stub, the test can state the expected output: That the output is equal to the output that <code>renderer.Success</code> would return.</p></blockquote>

            <p>Coupled with the explanation ("[the test] has less of an opinion about the implementation, which means that it's marginally less coupled to it"), this makes a lot of sense, with the only caveat that in more production-like cases comparing the output would be harder (e.g., if <code>IRenderer</code> operates on <code>HttpContext</code> to produce a full HTTP response), but that's a technicality that can be sorted out with proper assertion library. But let's now look at the <code>IStateValidator</code> part:</p>

            <blockquote><p>as far as executable specifications go, this test doesn't reflect reality. There's only one <code>Validate</code> implementation, and it doesn't behave like that. Rather, it'll return true when code is equal to <code>knownState.expectedCode</code>. The test poorly communicates that behaviour. </p></blockquote>

            <p>Here you act with the opposite intent: you want the test to communicate the specification, and thus be explicitly tied to the logic in the implementation (if not the actual code of it). There are two thing about that that bother me. First of all, it's somewhat inconsistent, so it makes it harder for me to choose which path to follow when testing the next code I'd write (or articulating to another developer how they should do it). But what's more important - and that comes from my example being <em>minimal</em>, as you've already noted - is that the validation logic might be more complicated, and thus the setup would be complicated as well. And as you've already mentioned on Twitter, when chaging the code in the validator implementation, you might be forced to change the implementation in the test, even if the test is more about the controller itself.</p>

            <p>There's also another frame for the same issue: the original test read as (at least for me): "if the state is valid, we return successful response based on this state". It didn't matter what is "valid" not did it matter what is "successful response". The new tests reads as "if state in the repository matches passed code, we return successful response for the state". It still doesn't matter what is "successful response", but the definition of validity <em>does</em> matter. For me, this is a change of test meaning, and I'm not sure I understand where that leads me.</p>

            <p>Let's consider the following scenario: we need to add another validity criteria, such as "state in repository has an expiration date, and this date should be in the future". We obviously need to add a couple of tests for this (negative and positive). Where do we add them? I'd say we add them into the tests for the validator itself (which are "not shown" for the purposes of brevity), but then it feels weird that we <em>also</em> need to change this "happy path" test...</p>
        </div>
        <div class="comment-date">2023-04-03 21:24 UTC</div>
    </div>

    <div class="comment" id="1a4c308c3b01a85c1b953d2051033b69">
        <div class="comment-author"><a href="https://github.com/AnthonyLloyd">Anthony Lloyd</a></div>
        <div class="comment-content">
            <p>Thanks for showing CsCheck. I've put in a PR to show how I would refactor the CsCheck tests and will attempt to explain some of the design choices of CsCheck.</p>

            <p>First of all, it may be a personal opinion but I don't really tend to use query syntax for CsCheck. I prefer to see the SelectManys and there are a number of additional overloads that simplify ranging and composing Gens.</p>

            <p>On the design of CsCheck, I build it to not use reflection, attributes or target test frameworks. I've seen the very difficult problems these lead to (for author and user) when you try to move past simple examples.</p>

            <p>I wanted the user to be able to move from simple general type generators to ranged complex types easily in a fluent style. No Arbs, attributes, PositiveInt type etc.</p>

            <p>CsCheck has automatic shrinking even for the most complex types that just comes out of composing Gens.</p>

            <p>I think some of the reason it was so easy to extend the library to areas such as concurrency testing was because of this simplicity (as well as the random shrinking insight).</p>
        
            <pre><code style="background-color: #eee;border: 1px solid #999;display:block;padding:5px;">Gen&lt;Uri&gt; _genRedirect = Gen.OneOfConst(new Uri("https://example.com"), new Uri("https://example.org"));

[Fact]
public void HappyPath()
{
    Gen.Select(Gen.String, Gen.String, Gen.Bool, _genRedirect)
    .Sample((state, expectedCode, isMobile, redirect) =>
    {
    var code = expectedCode;
    var knownState = (expectedCode, isMobile, redirect);
    var repository = new RepositoryStub { { state, knownState } };
    var sut = new Controller(repository);
    var actual = sut.Complete(state, code);
    var expected = Renderer.Success(knownState);
    return actual == expected;
    });
}</code></pre>
        </div>
        <div class="comment-date">2023-04-04 23:56 UTC</div>
    </div>

    <div class="comment" id="076f05eef3f649eab07392dc2ac83023">
        <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
        <div class="comment-content">
            <p>
                Sergei, thank you for writing. I'm afraid all of this is context-dependent, and I seem to constantly fail giving enough context. It's a fair criticism that I seem to employ inconsistent heuristics when making technical decisions. Part of it is caused by my lack of context. The code base is deliberately stripped of context, which has many other benefits, but gives me little to navigate after. I'm flying blind, so to speak. I've had to (implicitly) imagine some forces acting on the software in order to make technical decisions. Since we haven't explicitly outlined such forces, I've had to make them up as I went. It's quite possible, even, that I've imagined one set of forces in one place, and another set somewhere else. If so, no wonder the decisions are inconsistent.
            </p>
            <p>
                What do I mean by <em>forces?</em> I'm thinking of the surrounding context that you have to take into a account when making technical decisions about code: Is the current feature urgent? Is it a bug already in production? Is this a new system with a small code base? Or is it an old system with a large code base? Do you have good automated tests? Do you have a Continuous Delivery pipeline? Are you experiencing problems with code quality? What does the team makeup look like? Do you have mostly seasoned veterans who've worked in that code base for years? Or do you have many newcomers? Is the system public-facing or internal? Is it a system, even, or a library or framework? What sort of organisation owns the software? Is it a product group? Or a cost centre? What is the organization's goals? How are you incentivized? How are other stakeholders incentivized?
            </p>
            <p>
                As you can imagine, I can keep going, asking questions like these, and they may all be relevant. Clearly, we can't expect a self-contained minimal example to also include all such superstructure, so that's what I (inconsistently) have to imagine, on the fly.
            </p>
            <p>
                I admit that the decisions I describe seem inconsistent, and the explanation may simply be what is already implied above: I may have had a different context in mind when I made one, and a variation in mind when I made the other.
            </p>
            <p>
                That's hardly the whole story, though. I didn't start my answer with the above litany of forces only to make a bad excuse for myself. Rather, what I had in mind was to argue that I use a wider context when making decisions. That context is not just technical, but includes, among many other considerations, the team structure.
            </p>
            <p>
                As an example, I was recently working with some students in a university setting. These are people in their early twenties, with only a few months of academic programming under their belt, as well as, perhaps, a few years of hobby programming. They'd just been introduced to Git and GitHub a few weeks earlier, C# a month before that. I was trying to teach them how to use Git and GitHub, how to structure decent C# code, and many other things. During our project, they did send me a few pull requests I would have immediately rejected from a professional programmer. In this particular context, however, that would have been counter-productive. These students were doing a good job, based on their level of experience, and they needed the sense of accomplishment that I would (often, but not always) accept their code.
            </p>
            <p>
                I could have insisted on a higher code quality, and I would also have been able to teach it to anyone patient enough to listen. One thing I've learned all too slowly in my decades of working with other people is that most people aren't as patient with me as I'd like them to be. I need to explicitly consider how to motivate my collaborators.
            </p>
            <p>
                Here's another example: Years ago, I worked with a rag-tag team hastily assembled via word-of-mouth of some fine European freelancers. My challenge here was another. These people were used to be on top of their game - usually the ones brought in to an organisation because they were the best. I needed them to work together, and among other things, it meant showing them that even though they might think that their way was the best way, other ways exist. I wanted them to be able to work together and produce code with shared ownership. At the beginning, I was rather strict with my standards, clearly bruising a few egos, but ultimately several members have told what a positive transformative experience it was for them. It was a positive transformative experience for me, too.
            </p>
            <p>
                I discuss all of this because you, among various points, mention the need to be able to articulate to other developers how to make technical decisions about tests. The point is that there's a lot of context that goes into making decisions, and hardly a one-size-fits-all heuristic.
            </p>
            <p>
                What <em>usually</em> guides me is an emphasis on <em>coupling</em>, and that's also, I believe, what ultimately motivated me here. There's always going to be <em>some</em> coupling between tests and production code, but the less the better. For example, when considering whether how to write an assertion, I consider whether a change in production code's behaviour would cause a test to break.
            </p>
            <p>
                Consider, for example, the <code>renderer</code> in the present example. How important is the exact output? What happens if I change a character in the string that is being returned?
            </p>
            <p>
                That's a good example of context being important. If that output is part of an implementation of a network protocol or some other technical spec, just one character change could, indeed, imply that your implementation is off spec. In that case, we do want to test the exact output, and we do want the test to fail if the output changes.
            </p>
            <p>
                On the other hand, if the output is a piece of UI, or perhaps an error message, then the exact wording is likely to change over time. Since this doesn't really imply a change in <em>behaviour</em>, changing such a string output shouldn't break a test.
            </p>
            <p>
                You need that wider context in order to make decisions like that: If we change the System Under Test in this way, will the test break? Should it? What if we change it in another way?
            </p>
            <p>
                This is relevant in order to address your final concern: What if you now decide that the expiration date should be in the future? The way you describe it, it sounds like this strengthens the preconditions of the system - in other words, it <a href="/2021/12/13/backwards-compatibility-as-a-profunctor">breaks backwards compatibility</a>. So yes, making that change may break existing tests, but this could be an indication that it's also going to break existing clients.
            </p>
            <p>
                <em>If</em> you have any clients, that is. Again, you know your context better than I do, so only you can decide whether making such a change is okay. I can think of situations where is, but I usually find myself in contexts where it isn't, so I tend to err on the side of avoiding breaking changes.
            </p>
        </div>
        <div class="comment-date">2023-04-09 14:28 UTC</div>
    </div>

    <div class="comment" id="f2fe826964404792954ddaa4155c7be6">
        <div class="comment-author"><a href="https://github.com/srogovtsev">Sergei Rogovtcev</a></div>
        <div class="comment-content">
            <p>Mark, thank you for taking the time to discuss this.</p>

            <p>Having the magic word "architect" somewhere in my title, I know the importance of context, and in fact that would usually be the first counter-question that I have for somebody coming at me with a question: "what is your context?". So here we are, me being contractually obliged to strip as much context from my code as possible, and you having to reinvent it back from your experience. On the other hand, this allows us to point out which decisions are actually context-driven, and how different contexts affect them.</p>

            <p>With that in mind, I can actually propose two different contexts to reframe the decisions above, so that we could arrive at more insights.</p>

            <p>The first would be an imaginary context, which I had in mind when writing the code, but haven't thought of communicating: the <code>renderer</code> is as important as the <code>validator</code>. In case of "mobile" state the consumer is actually a mobile application, so we need to know we've produced the right JSON it will consume, and in case of non-"mobile" state the consumer is the browser, which again needs to be properly redirected. In my mind, this is no less important than the validation logic itself, because breaking it will break at least one consumer (mobile), and more likely both of them. Thus, according to the logic above, this is a compatibility issue, and as such we need to explicitly spell this behavior in the tests. Which gives us six outcome branches... six tests? Or something more complicated? This is especially interesting, considering the fact that we can test the <code>renderer</code> in isolation, so we'd be either duplicating our tests... or just just discarding the isolated tests for the <code>renderer</code>?</p>

            <p>And then here's the actual real context, which I can thankfully divulge to this extent: this is, in fact, a <em>migration</em> problem, when we move from one externally-facing framework (i.e. ASP.NET Web API) to another (i.e. ASP.NET Core). So I am not, in fact, concerned about the validation at all - I'm concerned about the data being properly <em>passed</em> to the validator (because the validator already existed, and worked properly, I'm just calling it from another framework), its result properly handled in the controller (which I am replacing), and then I'm concerned that despite the heavy changes between ASP.NET versions I'm still rendering the output in the exactly same way.</p>

            <p>Now that I'm thinking about it, it seems grossly unfair that I've hidden this context beforehand, but then, I didn't see how it was affecting the decisions in test design. So hopefully we can still find some use in this.</p>
        </div>
        <div class="comment-date">2023-04-10 18:03 UTC</div>
    </div>

    <div class="comment" id="82b07a802bd54507afb0aa90bfd827c8">
        <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
        <div class="comment-content">
            <p>
                Anthony, thank you for writing. I didn't intend to disparage CsCheck. Having once run <a href="https://github.com/AutoFixture/AutoFixture/">a moderately successful open source project</a>, I've learned that it's a good idea to limit the scope to a functional minimum. I'm not complaining about the design decisions made for CsCheck.
            </p>
            <p>
                I was a bit concerned that a casual reader might compare the CsCheck example with the previous code and be put off by the apparent complexity. I admit that your example looks less complex than mine, so to address that particular concern, I could have used code similar to yours.
            </p>
            <p>
                Whether one prefers the syntactic sugar of query syntax or the more explicit use of <code>SelectMany</code> is, to a degree, subjective. There are, on the other hand, some cases where one is objectively better than the other. One day I should write an article about that.
            </p>
            <p>
                I agree that the test-framework integration that exists in FsCheck is less than ideal. I'm not wishing for anything like that. Something declarative, however, would be nice. Contrary to you, I consider wrapper types like <code>PositiveInt</code> to be a boon, but perhaps not like they're implemented in FsCheck. (And this, by the way, isn't to harp on FsCheck either; I only bring up those examples because FsCheck has more of that kind of API than Hedgehog does.) The Haskell <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> approach is nice: While a wrapper like <a href="https://hackage.haskell.org/package/QuickCheck/docs/Test-QuickCheck.html#t:Positive">Positive</a> is predefined in the package, it's just an <code>Arbitrary</code> instance. There's really nothing special about it, and you can easily define domain-specific wrappers for your own testing purposes. Here's an example: <a href="/2019/09/02/naming-newtypes-for-quickcheck-arbitraries">Naming newtypes for QuickCheck Arbitraries</a>. I'm wondering if something similar wouldn't be possible with interfaces in .NET.
            </p>
        </div>
        <div class="comment-date">2023-04-13 8:46 UTC</div>
    </div>

    <div class="comment" id="ee233e2d67954197afcaa98d7637fda1">
        <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
        <div class="comment-content">
            <p>
                Sergei, thank you for writing. I'm sorry if I came across as condescending or implying that you weren't aware that context matters. Of course you do. I was mostly trying to reconstruct my own decision process, which is far less explicit than you might like.
            </p>
            <p>
                Regarding the renderer component, I understand that testing such a thing in reality may be more involved than the toy example we're looking at. My first concern is to avoid duplicating efforts too much. Again, however, the external behaviour should be the primary concern. I'm increasingly <a href="/2021/03/01/pendulum-swing-internal-by-default">shifting towards making more and more things internal</a>, as long as I can still test them via the application boundary. As I understand it, this is the same concern that <a href="https://dannorth.net/introducing-bdd/">made Dan North come up with behaviour-driven development</a>. I'm also concerned primarily with testing the behaviour of systems, just without all the Gherkin overhead.
            </p>
            <p>
                There comes a time, however, where testing everything through an external API becomes too awkward. I'm not adverse to introduce or make public classes or functions to enable testing at a different abstraction level. Doing that, however, represents a bet that it's possible to keep the new component's API stable enough that it isn't going to cause too much test churn. Still, if we imagine that we've already made such a decision, and that we now have some renderer component, then it's only natural to test it thoroughly. Then, in order to avoid duplicating assertions, we can state, as I did in this article, that the overall system should expect to see whatever the renderer component returns.
            </p>
            <p>
                That was, perhaps, too wordy an explanation. Perhaps this is more helpful: Don't repeat yourself. What has been asserted in one place shouldn't be asserted in another place.
            </p>
            <p>
                The other example you mention, about migrating to another framework, reminds me of two things.
            </p>
            <p>
                The first is that we shouldn't forget about other ways of verifying code correctness. We've mostly been discussing black-box testing, and while it can be <a href="/2019/10/07/devils-advocate">an interesting exercise to imagine an adversary developer</a>, in general <a href="/2023/03/20/on-trust-in-software-development">that's rarely the reality</a>. Are there other ways to verify that methods are called with the correct values? How about <em>looking</em> at the code? Consistent code reviews are good at detecting bugs.
            </p>
            <p>
                The second observation is that if you already have two working components (validator and renderer) you can treat them as <a href="https://en.wikipedia.org/wiki/Test_oracle">Test Oracles</a>. This still works well with property-based testing. Write tests based on equivalence classes and get a property-based testing framework to sample from those classes. Then use the Test Oracles to define the expected output. That's essentially what I have done in this article.
            </p>
            <p>
                Does it <em>prove</em> that your framework-based code calls the components with the correct arguments? No, not like if you'd used a Test Spy. Property-based testing produces knowledge reminiscent of the kind of knowledge produced by experimental physics; not the kind of axiomatic knowledge produced by mathematics. That's why I named this article series <em>Epistemology of interaction testing.</em>
            </p>
            <p>
                Is it wrong to test with Stubs or Spies in a case like this? Not necessarily. Ultimately, what I try to do with this blog is to investigate and present alternatives. Only once we have alternatives do we have choices.
            </p>
        </div>
        <div class="comment-date">2023-04-15 15:53 UTC</div>
    </div>
</div>
