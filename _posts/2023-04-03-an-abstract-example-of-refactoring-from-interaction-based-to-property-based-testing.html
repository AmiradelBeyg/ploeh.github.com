---
layout: post
title: "An abstract example of refactoring from interaction-based to property-based testing"
description: "A C# example with xUnit.net and CsCheck"
date: 2023-04-03 6:02 UTC
tags: [Unit Testing, Property-based Testing]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        This is the first comprehensive example that accompanies the article <a href="/2023/02/13/epistemology-of-interaction-testing">Epistemology of interaction testing</a>. In that article, I argue that in a code base that leans toward functional programming (FP), property-based testing is a better fit than interaction-based testing. In this example, I will show how to refactor simple interaction-based tests into a property-based tests.
    </p>
    <p>
        This small article series was prompted by an email from Sergei Rogovtsev, who was kind enough to furnish <a href="https://github.com/srogovtsev/mocks-in-tests">example code</a>. I'll use his code as a starting point for this example, so I've <a href="https://github.com/ploeh/mocks-in-tests">forked the repository</a>. If you want to follow along, all my work is in a branch called <em>no-mocks</em>. That branch simply continues off the <em>master</em> branch.
    </p>
    <h3 id="5fe789d2b85b449fa2677bbcbf095bfc">
        Interaction-based testing <a href="#5fe789d2b85b449fa2677bbcbf095bfc">#</a>
    </h3>
    <p>
        Sergei Rogovtsev writes:
    </p>
    <blockquote>
        <p>
            "A major thing to point out here is that I'm not following TDD here not by my own choice, but because my original question arose in a context of a legacy system devoid of tests, so I choose to present it to you in the same way. I imagine that working from tests would avoid a lot of questions."
        </p>
    </blockquote>
    <p>
        Even when using test-driven development (TDD), most code bases I've seen make use of <a href="http://xunitpatterns.com/Test%20Stub.html">Stubs</a> and <a href="http://xunitpatterns.com/Mock%20Object.html">Mocks</a> (or, rather, <a href="http://xunitpatterns.com/Test%20Spy.html">Spies</a>). In an object-oriented context this can make much sense. After all, a catch phrase of object-oriented programming is <em>tell, don't ask</em>.
    </p>
    <p>
        If you base API design on that principle, you're modelling side effects, and it makes sense that tests use Spies to verify those side effects. The book <a href="/ref/goos">Growing Object-Oriented Software, Guided by Tests</a> is a good example of this approach. Thus, even if you follow established good TDD practice, you could easily arrive at a code base reminiscent of Sergei Rogovtsev's example. I've written plenty of such code bases myself.
    </p>
    <p>
        Sergei Rogovtsev then extracts a couple of components, leaving him with a <code>Controller</code> class looking like this:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Complete</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>&nbsp;=&nbsp;_repository.GetState(state);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">try</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(_stateValidator.Validate(code,&nbsp;knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;_renderer.Success(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;_renderer.Failure(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">catch</span>&nbsp;(Exception&nbsp;<span style="font-weight:bold;color:#1f377f;">e</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;_renderer.Error(knownState,&nbsp;e);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        This code snippet doesn't show the entire class, but only its solitary action method. Keep in mind that the entire repository is available on GitHub if you want to see the surrounding code.
    </p>
    <p>
        The <code>Complete</code> method orchestrates three injected dependencies: <code>_repository</code>, <code>_stateValidator</code>, and <code>_renderer</code>. The question that Sergei Rogovtsev asks is how to test this method. You may think that it's so simple that you don't need to test it, but keep in mind that this is a <a href="https://en.wikipedia.org/wiki/Minimal_reproducible_example">minimal and self-contained example</a> that stands in for something more complicated.
    </p>
    <p>
        The method has a cyclomatic complexity of <em>3</em>, so <a href="/2019/12/09/put-cyclomatic-complexity-to-good-use">you need at least three test cases</a>. That's also what Sergei Rogovtsev's code contains. I'll show each test case in turn, while I refactor them.
    </p>
    <p>
        The overall question is still this: Both <code>IStateValidator</code> and <code>IRenderer</code> interfaces have only a single production implementation, and in both cases the implementations are <a href="https://en.wikipedia.org/wiki/Pure_function">pure functions</a>. If interaction-based testing is suboptimal, is there a better way to test this code?
    </p>
    <p>
        As I outlined in <a href="/2023/02/13/epistemology-of-interaction-testing">the introductory article</a>, I consider property-based testing a good alternative. In the following, I'll refactor the tests. Since the tests already use <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a>, most of the preliminary work can be done without choosing a property-based testing framework. I'll postpone that decision until I need it.
    </p>
    <h3 id="ca095000df004ef9b7cb7c022071f76b">
        State validator <a href="#ca095000df004ef9b7cb7c022071f76b">#</a>
    </h3>
    <p>
        The <code>IStateValidator</code> interface has a single implementation:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">StateValidator</span>&nbsp;:&nbsp;IStateValidator
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Validate</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;(<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;code&nbsp;==&nbsp;knownState.expectedCode;
}</pre>
    </p>
    <p>
        The <code>Validate</code> method is a pure function, so it's completely deterministic. It means that you don't have to hide it behind an interface and replace it with a <a href="https://martinfowler.com/bliki/TestDouble.html">Test Double</a> in order to control it. Rather, just feed it proper data. Still, that's not what the interaction-based tests do:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;_stateValidator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">validator</span>&nbsp;=&gt;&nbsp;validator.Validate(code,&nbsp;knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(<span style="color:blue;">true</span>);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Success(knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
 
&nbsp;&nbsp;&nbsp;&nbsp;_target
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        These tests use AutoFixture, which will make it a bit easier to refactor them to properties. It also makes the test a bit more abstract, since you don't get to see concrete test data. In short, the <code>[AutoData]</code> attribute will generate a random <code>state</code> string, a random <code>code</code> string, and so on. If you want to see an example with concrete test data, the next article shows that variation.
    </p>
    <p>
        The test uses <a href="https://github.com/moq/moq4">Moq</a> to control the behaviour of the Test Doubles. It states that the <code>Validate</code> method will return <code>true</code> when called with certain arguments. This is possible because you can redefine its behaviour, but as far as executable specifications go, this test doesn't reflect reality. There's only one <code>Validate</code> implementation, and it doesn't behave like that. Rather, it'll return <code>true</code> when <code>code</code> is equal to <code>knownState.expectedCode</code>. The test poorly communicates that behaviour.
    </p>
    <p>
        Even before I replace AutoFixture with CsCheck, I'll prepare the test by making it more honest. I'll replace the <code>code</code> parameter with a <a href="http://xunitpatterns.com/Derived%20Value.html">Derived Value</a>:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//&nbsp;The&nbsp;rest&nbsp;of&nbsp;the&nbsp;test...</span></pre>
    </p>
    <p>
        I've removed the <code>code</code> parameter to replace it with a variable derived from <code>knownState</code>. Notice how this <em>documents</em> the overall behaviour of the (sub-)system.
    </p>
    <p>
        This also means that I can now replace the <code>IStateValidator</code> Test Double with the real, pure implementation:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Success(knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(_repository,&nbsp;<span style="color:blue;">new</span>&nbsp;StateValidator(),&nbsp;_renderer.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        I give the <code>Failure</code> test case the same treatment:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Failure</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode&nbsp;+&nbsp;<span style="color:#a31515;">&quot;1&quot;</span>;&nbsp;<span style="color:green;">//&nbsp;Any&nbsp;extra&nbsp;string&nbsp;will&nbsp;do</span>
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Failure(knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(_repository,&nbsp;<span style="color:blue;">new</span>&nbsp;StateValidator(),&nbsp;_renderer.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        The third test case is a bit more interesting.
    </p>
    <h3 id="aa150cf1b817416ea49e30cdc8b27ac7">
        An impossible case <a href="#aa150cf1b817416ea49e30cdc8b27ac7">#</a>
    </h3>
    <p>
        Before I make any changes to it, the third test case is this:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Error</span>(
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,
&nbsp;&nbsp;&nbsp;&nbsp;Exception&nbsp;<span style="font-weight:bold;color:#1f377f;">e</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;_stateValidator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">validator</span>&nbsp;=&gt;&nbsp;validator.Validate(code,&nbsp;knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Throws(e);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Error(knownState,&nbsp;e))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
 
&nbsp;&nbsp;&nbsp;&nbsp;_target
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        This test case verifies the behaviour of the <code>Controller</code> class when the <code>Validate</code> method throws an exception. If we want to instead use the real, pure implementation, how can we get it to throw an exception? Consider it again:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Validate</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;(<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;code&nbsp;==&nbsp;knownState.expectedCode;</pre>
    </p>
    <p>
        As far as I can tell, there's no way to get this method to throw an exception. You might suggest passing <code>null</code> as the <code>knownState</code> parameter, but that's not possible. This is a new version of C# and the <a href="https://learn.microsoft.com/dotnet/csharp/language-reference/builtin-types/nullable-reference-types">nullable reference types</a> feature is turned on. I spent some fifteen minutes trying to convince the compiler to pass a <code>null</code> argument in place of <code>knownState</code>, but I couldn't make it work in a unit test.
    </p>
    <p>
        That's interesting. The <code>Error</code> test is exercising a code path that's impossible in production. Is it redundant?
    </p>
    <p>
        It might be, but here I think that it's more an artefact of the process. Sergei Rogovtsev has provided a minimal example, and as it sometimes happens, perhaps it's a bit too minimal. He did write, however, that he considered it essential for the example that the logic involved more that an Boolean <em>true/false</em> condition. In order to keep with the spirit of the example, then, I'm going to modify the <code>Validate</code> method so that it's also possible to make it throw an exception:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Validate</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;(<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState&nbsp;==&nbsp;<span style="color:blue;">default</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;ArgumentNullException(nameof(knownState));
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;code&nbsp;==&nbsp;knownState.expectedCode;
}</pre>
    </p>
    <p>
        The method now throws an exception if you pass it a <code>default</code> value for <code>knownState</code>. From an implementation standpoint, there's no reason to do this, so it's only for the sake of the example. You can now test how the <code>Controller</code> handles an exception:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Error</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;<span style="color:blue;">default</span>);
&nbsp;&nbsp;&nbsp;&nbsp;_renderer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Setup(<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&gt;&nbsp;renderer.Error(<span style="color:blue;">default</span>,&nbsp;It.IsAny&lt;Exception&gt;()))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Returns(response);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(_repository,&nbsp;<span style="color:blue;">new</span>&nbsp;StateValidator(),&nbsp;_renderer.Object);
 
&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(response);
}</pre>
    </p>
    <p>
        The test no longer has a reference to the specific <code>Exception</code> object that <code>Validate</code> is going to throw, so instead it has to use Moq's <code>It.IsAny</code> API to configure the <code>_renderer</code>. This is, however, only an interim step, since it's now time to treat that dependency in the same way as the validator.
    </p>
    <h3 id="389a212d80a4445c99917cbd15b043eb">
        Renderer <a href="#389a212d80a4445c99917cbd15b043eb">#</a>
    </h3>
    <p>
        The <code>Renderer</code> class has three methods, and they are all pure functions:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">Renderer</span>&nbsp;:&nbsp;IRenderer
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Success</span>((<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState.isMobile)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;{\&quot;success\&quot;:&nbsp;true,&nbsp;\&quot;redirect\&quot;:&nbsp;\&quot;&quot;</span>&nbsp;+&nbsp;knownState.redirect&nbsp;+&nbsp;<span style="color:#a31515;">&quot;\&quot;}&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;302&nbsp;Location:&nbsp;&quot;</span>&nbsp;+&nbsp;knownState.redirect;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Failure</span>((<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState.isMobile)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;{\&quot;success\&quot;:&nbsp;false,&nbsp;\&quot;redirect\&quot;:&nbsp;\&quot;login\&quot;}&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;302&nbsp;Location:&nbsp;login&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Error</span>((<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;Exception&nbsp;<span style="font-weight:bold;color:#1f377f;">e</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState.isMobile)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;{\&quot;error\&quot;:&nbsp;\&quot;&quot;</span>&nbsp;+&nbsp;e.Message&nbsp;+&nbsp;<span style="color:#a31515;">&quot;\&quot;}&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;<span style="color:#a31515;">&quot;500&quot;</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        Since all three methods are deterministic, automated tests can control their behaviour simply by passing in the appropriate arguments:
    </p>
    <p>
        <pre>[Theory]
[AutoData]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;(<span style="color:blue;">string</span>,&nbsp;<span style="color:blue;">bool</span>,&nbsp;Uri)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">response</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;_repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">renderer</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Renderer();
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(_repository,&nbsp;renderer);
 
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>&nbsp;=&nbsp;renderer.Success(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(expected);
}</pre>
    </p>
    <p>
        Instead of configuring an <code>IRenderer</code> Stub, the test can state the <code>expected</code> output: That the output is equal to the output that <code>renderer.Success</code> would return.
    </p>
    <p>
        Notice that the test doesn't <em>require</em> that the implementation calls <code>renderer.Success</code>. It only requires that the output is equal to the output that <code>renderer.Success</code> would return. Thus, it has less of an opinion about the implementation, which means that it's marginally less coupled to it.
    </p>
    <p>
        You might protest that the test now duplicates the implementation code. This is partially true, but no more than the previous incarnation of it. Before, the test used Moq to explicitly <em>require</em> that <code>renderer.Success</code> gets called. Now, there's still coupling, but this refactoring reduces it.
    </p>
    <p>
        As a side note, this may partially be an artefact of the process. Here I'm refactoring tests while keeping the implementation intact. Had I started with a property, perhaps the test would have turned out differently, and less coupled to the implementation. If you're interested in a successful exercise in using property-based TDD, you may find my article <a href="/2021/06/28/property-based-testing-is-not-the-same-as-partition-testing">Property-based testing is not the same as partition testing</a> interesting.
    </p>
    <h3 id="81bbcfc59f5c48df8ee15f9d1bad47cf">
        Simplification <a href="#81bbcfc59f5c48df8ee15f9d1bad47cf">#</a>
    </h3>
    <p>
        Once you've refactored the tests to use the pure functions as dependencies, you no longer need the interfaces. The interfaces <code>IStateValidator</code> and <code>IRenderer</code> only existed to support testing. Now that the tests no longer use the interfaces, you can delete them.
    </p>
    <p>
        Furthermore, once you've removed those interfaces, there's no reason for the classes to support instantiation. Instead, make them <code>static</code>:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">StateValidator</span>
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">bool</span>&nbsp;<span style="color:#74531f;">Validate</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:blue;">string</span>&nbsp;expectedCode,&nbsp;<span style="color:blue;">bool</span>&nbsp;isMobile,&nbsp;Uri&nbsp;redirect)&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(knownState&nbsp;==&nbsp;<span style="color:blue;">default</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;ArgumentNullException(nameof(knownState));
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;code&nbsp;==&nbsp;knownState.expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        You can do the same for the <code>Renderer</code> class.
    </p>
    <p>
        This doesn't change the overall <em>flow</em> of the <code>Controller</code> class' <code>Complete</code> method, although the implementation details have changed a bit:
    </p>
    <p>
        <pre><span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#74531f;">Complete</span>(<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>)
{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>&nbsp;=&nbsp;_repository.GetState(state);
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">try</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">if</span>&nbsp;(StateValidator.Validate(code,&nbsp;knownState))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;Renderer.Success(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;Renderer.Failure(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">catch</span>&nbsp;(Exception&nbsp;<span style="font-weight:bold;color:#1f377f;">e</span>)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight:bold;color:#8f08c4;">return</span>&nbsp;Renderer.Error(knownState,&nbsp;e);
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre>
    </p>
    <p>
        <code>StateValidator</code> and <code>Renderer</code> are no longer injected dependencies, but rather 'modules' that affords pure functions.
    </p>
    <p>
        Both the <code>Controller</code> class and the tests that cover it are simpler.
    </p>
    <h3 id="984cd44e8f6545ddafa673a411e188f1">
        Properties <a href="#984cd44e8f6545ddafa673a411e188f1">#</a>
    </h3>
    <p>
        So far I've been able to make all these changes without introducing a property-based testing framework. This was possible because the tests already used AutoFixture, which, while not a property-based testing framework, already strongly encourages you to write tests without literal test data.
    </p>
    <p>
        This makes it easy to make the final change to property-based testing. On the other hand, it's a bit unfortunate from a pedagogical perspective. This means that you didn't get to see how to refactor a 'traditional' unit test to a property. The next article in this series will plug that hole, as well as show a more realistic example.
    </p>
    <p>
        It's now time to pick a property-based testing framework. On .NET you have a few choices. Since this code base is C#, you may consider a framework written in C#. I'm not convinced that this is necessarily better, but it's a worthwhile experiment. Here I've used <a href="https://github.com/AnthonyLloyd/CsCheck">CsCheck</a>.
    </p>
    <p>
        Since the tests already used randomly generated test data, the conversion to CsCheck is relatively straightforward. I'm only going to show one of the tests. You can always find the rest of the code in the Git repository.
    </p>
    <p>
        <pre>[Fact]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">void</span>&nbsp;<span style="font-weight:bold;color:#74531f;">HappyPath</span>()
{
&nbsp;&nbsp;&nbsp;&nbsp;(<span style="color:blue;">from</span>&nbsp;state&nbsp;<span style="color:blue;">in</span>&nbsp;Gen.String
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">from</span>&nbsp;expectedCode&nbsp;<span style="color:blue;">in</span>&nbsp;Gen.String
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">from</span>&nbsp;isMobile&nbsp;<span style="color:blue;">in</span>&nbsp;Gen.Bool
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;urls&nbsp;=&nbsp;<span style="color:blue;">new</span>[]&nbsp;{&nbsp;<span style="color:#a31515;">&quot;https://example.com&quot;</span>,&nbsp;<span style="color:#a31515;">&quot;https://example.org&quot;</span>&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">from</span>&nbsp;redirect&nbsp;<span style="color:blue;">in</span>&nbsp;Gen.OneOfConst(urls).Select(<span style="font-weight:bold;color:#1f377f;">s</span>&nbsp;=&gt;&nbsp;<span style="color:blue;">new</span>&nbsp;Uri(s))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">select</span>&nbsp;(state,&nbsp;(expectedCode,&nbsp;isMobile,&nbsp;redirect)))
&nbsp;&nbsp;&nbsp;&nbsp;.Sample((<span style="font-weight:bold;color:#1f377f;">state</span>,&nbsp;<span style="font-weight:bold;color:#1f377f;">knownState</span>)&nbsp;=&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;(<span style="font-weight:bold;color:#1f377f;">expectedCode</span>,&nbsp;<span style="color:blue;">_</span>,&nbsp;<span style="color:blue;">_</span>)&nbsp;=&nbsp;knownState;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">code</span>&nbsp;=&nbsp;expectedCode;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">repository</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;RepositoryStub();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repository.Add(state,&nbsp;knownState);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">sut</span>&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;Controller(repository);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;<span style="font-weight:bold;color:#1f377f;">expected</span>&nbsp;=&nbsp;Renderer.Success(knownState);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sut
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Complete(state,&nbsp;code)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.Should().Be(expected);
&nbsp;&nbsp;&nbsp;&nbsp;});
}</pre>
    </p>
    <p>
        Compared to the AutoFixture version of the test, this looks more complicated. Part of it is that CsCheck (as far as I know) doesn't have the same <a href="https://www.nuget.org/packages/AutoFixture.Xunit2/">integration with xUnit.net that AutoFixture has</a>. That might be an issue that someone could address; after all, <a href="https://fscheck.github.io/FsCheck/RunningTests.html">FsCheck has framework integration</a>, to name an example.
    </p>
    <p>
        <a href="/2023/02/13/epistemology-of-interaction-testing">Test data generators are monads</a> so you typically leverage whatever syntactic sugar a language offers to simplify monadic composition. <a href="/2022/03/28/monads">In C# that syntactic sugar is query syntax</a>, which explains that initial <code>from</code> block.
    </p>
    <p>
        The test does look too top-heavy for my taste. An equivalent problem appears in the next article, where I also try to address it. In general, the better monad support a language offers, the more elegantly you can address this kind of problem. C# isn't really there yet, whereas languages like <a href="https://fsharp.org/">F#</a> and <a href="https://www.haskell.org/">Haskell</a> offer superior alternatives.
    </p>
    <h3 id="b0e7738d8b0440bba33caa470fd440fb">
        Conclusion <a href="#b0e7738d8b0440bba33caa470fd440fb">#</a>
    </h3>
    <p>
        In this article I've tried to demonstrate how property-based testing is a viable alternative to using Stubs and Mocks for verification of composition. You can try to sabotage the <code>Controller.Complete</code> method in the <em>no-mocks</em> branch and see that one or more properties will fail.
    </p>
    <p>
        While the example code base that I've used for this article has the strength of being small and self-contained, it also suffers from a few weaknesses. It's perhaps a bit too abstract to truly resonate. It also uses AutoFixture to generate test data, which already takes it halfway towards property-based testing. While that makes the refactoring easier, it also means that it may not fully demonstrate how to refactor an example-based test to a property. I'll try to address these shortcomings in the next article.
    </p>
    <p>
        <strong>Next:</strong> A restaurant example of refactoring from example-based to property-based testing.
    </p>

</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>

    <div class="comment" id="0510331b953a4c308c3b01a918d2b65c">
        <div class="comment-author"><a href="https://github.com/srogovtsev">Sergei Rogovtcev</a></div>
        <div class="comment-content">
            <p>First of all, thanks again for continuing to explore this matter. This was very enlightening, but in the end, I was left with is a sense of subtle wrongness, which is very hard to pin down, and even harder to tell apart between "this is actually not right for me" and "this is something new I'm not accustomed to".</p>

            <p>I suppose that my main question would center around difference between your tests for <code>IStateValidator</code> and <code>IRenderer</code>. Let's start with the latter:</p>

            <blockquote><p>Instead of configuring an <code>IRenderer</code> Stub, the test can state the expected output: That the output is equal to the output that <code>renderer.Success</code> would return.</p></blockquote>

            <p>Coupled with the explanation ("[the test] has less of an opinion about the implementation, which means that it's marginally less coupled to it"), this makes a lot of sense, with the only caveat that in more production-like cases comparing the output would be harder (e.g., if <code>IRenderer</code> operates on <code>HttpContext</code> to produce a full HTTP response), but that's a technicality that can be sorted out with proper assertion library. But let's now look at the <code>IStateValidator</code> part:</p>

            <blockquote><p>as far as executable specifications go, this test doesn't reflect reality. There's only one <code>Validate</code> implementation, and it doesn't behave like that. Rather, it'll return true when code is equal to <code>knownState.expectedCode</code>. The test poorly communicates that behaviour. </p></blockquote>

            <p>Here you act with the opposite intent: you want the test to communicate the specification, and thus be explicitly tied to the logic in the implementation (if not the actual code of it). There are two thing about that that bother me. First of all, it's somewhat inconsistent, so it makes it harder for me to choose which path to follow when testing the next code I'd write (or articulating to another developer how they should do it). But what's more important - and that comes from my example being <em>minimal</em>, as you've already noted - is that the validation logic might be more complicated, and thus the setup would be complicated as well. And as you've already mentioned on Twitter, when chaging the code in the validator implementation, you might be forced to change the implementation in the test, even if the test is more about the controller itself.</p>

            <p>There's also another frame for the same issue: the original test read as (at least for me): "if the state is valid, we return successful response based on this state". It didn't matter what is "valid" not did it matter what is "successful response". The new tests reads as "if state in the repository matches passed code, we return successful response for the state". It still doesn't matter what is "successful response", but the definition of validity <em>does</em> matter. For me, this is a change of test meaning, and I'm not sure I understand where that leads me.</p>

            <p>Let's consider the following scenario: we need to add another validity criteria, such as "state in repository has an expiration date, and this date should be in the future". We obviously need to add a couple of tests for this (negative and positive). Where do we add them? I'd say we add them into the tests for the validator itself (which are "not shown" for the purposes of brevity), but then it feels weird that we <em>also</em> need to change this "happy path" test...</p>
        </div>
        <div class="comment-date">2023-04-03 21:24 UTC</div>
    </div>

    <div class="comment" id="1a4c308c3b01a85c1b953d2051033b69">
        <div class="comment-author"><a href="https://github.com/AnthonyLloyd">Anthony Lloyd</a></div>
        <div class="comment-content">
            <p>Thanks for showing CsCheck. I've put in a PR to show how I would refactor the CsCheck tests and will attempt to explain some of the design choices of CsCheck.</p>

            <p>First of all, it may be a personal opinion but I don't really tend to use query syntax for CsCheck. I prefer to see the SelectManys and there are a number of additional overloads that simplify ranging and composing Gens.</p>

            <p>On the design of CsCheck, I build it to not use reflection, attributes or target test frameworks. I've seen the very difficult problems these lead to (for author and user) when you try to move past simple examples.</p>

            <p>I wanted the user to be able to move from simple general type generators to ranged complex types easily in a fluent style. No Arbs, attributes, PositiveInt type etc.</p>

            <p>CsCheck has automatic shrinking even for the most complex types that just comes out of composing Gens.</p>

            <p>I think some of the reason it was so easy to extend the library to areas such as concurrency testing was because of this simplicity (as well as the random shrinking insight).</p>
        
            <pre><code style="background-color: #eee;border: 1px solid #999;display:block;padding:5px;">Gen&lt;Uri&gt; _genRedirect = Gen.OneOfConst(new Uri("https://example.com"), new Uri("https://example.org"));

[Fact]
public void HappyPath()
{
    Gen.Select(Gen.String, Gen.String, Gen.Bool, _genRedirect)
    .Sample((state, expectedCode, isMobile, redirect) =>
    {
    var code = expectedCode;
    var knownState = (expectedCode, isMobile, redirect);
    var repository = new RepositoryStub { { state, knownState } };
    var sut = new Controller(repository);
    var actual = sut.Complete(state, code);
    var expected = Renderer.Success(knownState);
    return actual == expected;
    });
}</code></pre>
        </div>
        <div class="comment-date">2023-04-04 23:56 UTC</div>
    </div>

    <div class="comment" id="076f05eef3f649eab07392dc2ac83023">
        <div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
        <div class="comment-content">
            <p>
                Sergei, thank you for writing. I'm afraid all of this is context-dependent, and I seem to constantly fail giving enough context. It's a fair criticism that I seem to employ inconsistent heuristics when making technical decisions. Part of it is caused by my lack of context. The code base is deliberately stripped of context, which has many other benefits, but gives me little to navigate after. I'm flying blind, so to speak. I've had to (implicitly) imagine some forces acting on the software in order to make technical decisions. Since we haven't explicitly outlined such forces, I've had to make them up as I went. It's quite possible, even, that I've imagined one set of forces in one place, and another set somewhere else. If so, no wonder the decisions are inconsistent.
            </p>
            <p>
                What do I mean by <em>forces?</em> I'm thinking of the surrounding context that you have to take into a account when making technical decisions about code: Is the current feature urgent? Is it a bug already in production? Is this a new system with a small code base? Or is it an old system with a large code base? Do you have good automated tests? Do you have a Continuous Delivery pipeline? Are you experiencing problems with code quality? What does the team makeup look like? Do you have mostly seasoned veterans who've worked in that code base for years? Or do you have many newcomers? Is the system public-facing or internal? Is it a system, even, or a library or framework? What sort of organisation owns the software? Is it a product group? Or a cost centre? What is the organization's goals? How are you incentivized? How are other stakeholders incentivized?
            </p>
            <p>
                As you can imagine, I can keep going, asking questions like these, and they may all be relevant. Clearly, we can't expect a self-contained minimal example to also include all such superstructure, so that's what I (inconsistently) have to imagine, on the fly.
            </p>
            <p>
                I admit that the decisions I describe seem inconsistent, and the explanation may simply be what is already implied above: I may have had a different context in mind when I made one, and a variation in mind when I made the other.
            </p>
            <p>
                That's hardly the whole story, though. I didn't start my answer with the above litany of forces only to make a bad excuse for myself. Rather, what I had in mind was to argue that I use a wider context when making decisions. That context is not just technical, but includes, among many other considerations, the team structure.
            </p>
            <p>
                As an example, I was recently working with some students in a university setting. These are people in their early twenties, with only a few months of academic programming under their belt, as well as, perhaps, a few years of hobby programming. They'd just been introduced to Git and GitHub a few weeks earlier, C# a month before that. I was trying to teach them how to use Git and GitHub, how to structure decent C# code, and many other things. During our project, they did send me a few pull requests I would have immediately rejected from a professional programmer. In this particular context, however, that would have been counter-productive. These students were doing a good job, based on their level of experience, and they needed the sense of accomplishment that I would (often, but not always) accept their code.
            </p>
            <p>
                I could have insisted on a higher code quality, and I would also have been able to teach it to anyone patient enough to listen. One thing I've learned all too slowly in my decades of working with other people is that most people aren't as patient with me as I'd like them to be. I need to explicitly consider how to motivate my collaborators.
            </p>
            <p>
                Here's another example: Years ago, I worked with a rag-tag team hastily assembled via word-of-mouth of some fine European freelancers. My challenge here was another. These people were used to be on top of their game - usually the ones brought in to an organisation because they were the best. I needed them to work together, and among other things, it meant showing them that even though they might think that their way was the best way, other ways exist. I wanted them to be able to work together and produce code with shared ownership. At the beginning, I was rather strict with my standards, clearly bruising a few egos, but ultimately several members have told what a positive transformative experience it was for them. It was a positive transformative experience for me, too.
            </p>
            <p>
                I discuss all of this because you, among various points, mention the need to be able to articulate to other developers how to make technical decisions about tests. The point is that there's a lot of context that goes into making decisions, and hardly a one-size-fits-all heuristic.
            </p>
            <p>
                What <em>usually</em> guides me is an emphasis on <em>coupling</em>, and that's also, I believe, what ultimately motivated me here. There's always going to be <em>some</em> coupling between tests and production code, but the less the better. For example, when considering whether how to write an assertion, I consider whether a change in production code's behaviour would cause a test to break.
            </p>
            <p>
                Consider, for example, the <code>renderer</code> in the present example. How important is the exact output? What happens if I change a character in the string that is being returned?
            </p>
            <p>
                That's a good example of context being important. If that output is part of an implementation of a network protocol or some other technical spec, just one character change could, indeed, imply that your implementation is off spec. In that case, we do want to test the exact output, and we do want the test to fail if the output changes.
            </p>
            <p>
                On the other hand, if the output is a piece of UI, or perhaps an error message, then the exact wording is likely to change over time. Since this doesn't really imply a change in <em>behaviour</em>, changing such a string output shouldn't break a test.
            </p>
            <p>
                You need that wider context in order to make decisions like that: If we change the System Under Test in this way, will the test break? Should it? What if we change it in another way?
            </p>
            <p>
                This is relevant in order to address your final concern: What if you now decide that the expiration date should be in the future? The way you describe it, it sounds like this strengthens the preconditions of the system - in other words, it <a href="/2021/12/13/backwards-compatibility-as-a-profunctor">breaks backwards compatibility</a>. So yes, making that change may break existing tests, but this could be an indication that it's also going to break existing clients.
            </p>
            <p>
                <em>If</em> you have any clients, that is. Again, you know your context better than I do, so only you can decide whether making such a change is okay. I can think of situations where is, but I usually find myself in contexts where it isn't, so I tend to err on the side of avoiding breaking changes.
            </p>
        </div>
        <div class="comment-date">2023-04-09 14:28 UTC</div>
    </div>
</div>
