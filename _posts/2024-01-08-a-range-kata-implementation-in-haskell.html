---
layout: post
title: "A Range kata implementation in Haskell"
description: "A first crack at the exercise."
date: 2024-01-08 7:06 UTC
tags: [Functional Programming, Haskell, Unit Testing]
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        This article is an instalment in <a href="/2024/01/01/variations-of-the-range-kata">a short series of articles on the Range kata</a>. Here I describe my first attempt at the exercise. As I usually advise people <a href="/2020/01/13/on-doing-katas">on doing katas</a>, the first time you try your hand at a kata, use the language with which you're most comfortable. To be honest, I may be most habituated to C#, having programmed in it since 2002, but on the other hand, I currently 'think in <a href="https://www.haskell.org/">Haskell</a>', and am often frustrated with C#'s lack of structural equality, higher-order abstractions, and support for functional expressions.
    </p>
    <p>
        Thus, I usually start with Haskell even though I always find myself struggling with the ecosystem. If you do, too, the source code is <a href="https://github.com/ploeh/RangeHaskell">available on GitHub</a>.
    </p>
    <p>
        I took my own advice by setting out with the explicit intent to follow <a href="https://codingdojo.org/kata/Range/">the Range kata description</a> as closely as possible. This kata doesn't beat about the bush, but instead just dumps a set of test cases on you. It wasn't clear if this is the most useful set of tests, or whether the order in which they're represented is the one most conducive to a good experience of test-driven development, but there was only one way to find out.
    </p>
    <p>
        I quickly learned, however, that the suggested test cases were insufficient in describing the behaviour in enough details.
    </p>
    <h3 id="287256d6f0fe412585cce5f16fcf5363">
        Containment <a href="#287256d6f0fe412585cce5f16fcf5363">#</a>
    </h3>
    <p>
        I started by adding the first two test cases as <a href="/2018/05/07/inlined-hunit-test-lists">inlined HUnit test lists</a>:
    </p>
    <p>
        <pre><span style="color:#a31515;">&quot;integer&nbsp;range&nbsp;contains&quot;</span>&nbsp;~:&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;(r,&nbsp;candidate,&nbsp;expected)&nbsp;&lt;-
&nbsp;&nbsp;&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Open&nbsp;6),&nbsp;[2,4],&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Open&nbsp;6),&nbsp;[-1,1,6,10],&nbsp;False)
&nbsp;&nbsp;&nbsp;&nbsp;]
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;r&nbsp;`contains`&nbsp;candidate
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;expected&nbsp;~=?&nbsp;actual</pre>
    </p>
    <p>
        I wasn't particularly keen on going full <a href="/2019/10/07/devils-advocate">Devil's Advocate</a> on the exercise. I could, on the other hand, trivially pass both tests with this obviously degenerate implementation:
    </p>
    <p>
        <pre><span style="color:blue;">import</span>&nbsp;Data.List
 
<span style="color:blue;">data</span>&nbsp;Endpoint&nbsp;a&nbsp;=&nbsp;Open&nbsp;a&nbsp;|&nbsp;Closed&nbsp;a&nbsp;<span style="color:blue;">deriving</span>&nbsp;(<span style="color:#2b91af;">Eq</span>,&nbsp;<span style="color:#2b91af;">Show</span>)
 
contains&nbsp;_&nbsp;candidate&nbsp;=&nbsp;[2]&nbsp;`isPrefixOf`&nbsp;candidate</pre>
    </p>
    <p>
        Reluctantly, I had to invent some additional test cases:
    </p>
    <p>
        <pre><span style="color:#a31515;">&quot;integer&nbsp;range&nbsp;contains&quot;</span>&nbsp;~:&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;(r,&nbsp;candidate,&nbsp;expected)&nbsp;&lt;-
&nbsp;&nbsp;&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;&nbsp;&nbsp;2&nbsp;,&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;6),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,4],&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;&nbsp;&nbsp;2&nbsp;,&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;6),&nbsp;[-1,1,6,10],&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;(-1),&nbsp;Closed&nbsp;10),&nbsp;[-1,1,6,10],&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;(-1),&nbsp;&nbsp;&nbsp;Open&nbsp;10),&nbsp;[-1,1,6,10],&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;(-1),&nbsp;&nbsp;&nbsp;Open&nbsp;10),&nbsp;&nbsp;[-1,1,6,9],&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;&nbsp;&nbsp;2,&nbsp;&nbsp;Closed&nbsp;&nbsp;6),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,5,6],&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;&nbsp;&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;6),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2,5],&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;&nbsp;&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;6),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">[]</span>,&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;&nbsp;&nbsp;2,&nbsp;&nbsp;Closed&nbsp;&nbsp;6),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3,7,4],&nbsp;False)
&nbsp;&nbsp;&nbsp;&nbsp;]
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;r&nbsp;`contains`&nbsp;candidate
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;expected&nbsp;~=?&nbsp;actual</pre>
    </p>
    <p>
        This was when I began to wonder whether it would have been easier to use property-based testing. That would entail, however, a departure from the kata's suggested test cases, so I decided to stick to the plan and then perhaps return to property-based testing when repeating the exercise.
    </p>
    <p>
        Ultimately I implemented the <code>contains</code> function this way:
    </p>
    <p>
        <pre><span style="color:#2b91af;">contains</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Foldable</span>&nbsp;t,&nbsp;<span style="color:blue;">Ord</span>&nbsp;a)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;(<span style="color:blue;">Endpoint</span>&nbsp;a,&nbsp;<span style="color:blue;">Endpoint</span>&nbsp;a)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;t&nbsp;a&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
contains&nbsp;(lowerBound,&nbsp;upperBound)&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;isHighEnough&nbsp;=&nbsp;<span style="color:blue;">case</span>&nbsp;lowerBound&nbsp;<span style="color:blue;">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closed&nbsp;x&nbsp;-&gt;&nbsp;(x&nbsp;&lt;=)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;&nbsp;x&nbsp;-&gt;&nbsp;(x&nbsp;&lt;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isLowEnough&nbsp;=&nbsp;<span style="color:blue;">case</span>&nbsp;upperBound&nbsp;<span style="color:blue;">of</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closed&nbsp;y&nbsp;-&gt;&nbsp;(&lt;=&nbsp;y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;&nbsp;y&nbsp;-&gt;&nbsp;&nbsp;(&lt;&nbsp;y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isContained&nbsp;x&nbsp;=&nbsp;isHighEnough&nbsp;x&nbsp;&amp;&amp;&nbsp;isLowEnough&nbsp;x
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;<span style="color:blue;">all</span>&nbsp;isContained</pre>
    </p>
    <p>
        In some ways it seems a bit verbose to me, but I couldn't easily think of a simpler implementation.
    </p>
    <p>
        One of the features I find so fascinating about Haskell is how <em>general</em> it enables me to be. While the tests use integers for concision, the <code>contains</code> function works with any <code>Ord</code> instance; not only <code>Integer</code>, but also <code>Double</code>, <code>Word</code>, <code>Day</code>, <code>TimeOfDay</code>, or some new type I can't even predict.
    </p>
    <h3 id="67c8d29aeb5d4c2ca18b4a6664cf6af8">
        All points <a href="#67c8d29aeb5d4c2ca18b4a6664cf6af8">#</a>
    </h3>
    <p>
        The next function suggested by the kata is a function to enumerate all points in a range. There's only a single test case, so again I added some more:
    </p>
    <p>
        <pre><span style="color:#a31515;">&quot;getAllPoints&quot;</span>&nbsp;~:&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;(r,&nbsp;expected)&nbsp;&lt;-
&nbsp;&nbsp;&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;&nbsp;&nbsp;Open&nbsp;6),&nbsp;[2..5]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;4,&nbsp;&nbsp;&nbsp;Open&nbsp;8),&nbsp;[4..7]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Closed&nbsp;6),&nbsp;[2..6]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;4,&nbsp;Closed&nbsp;8),&nbsp;[4..8]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;2,&nbsp;Closed&nbsp;6),&nbsp;[3..6]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;4,&nbsp;Closed&nbsp;8),&nbsp;[5..8]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;2,&nbsp;&nbsp;&nbsp;Open&nbsp;6),&nbsp;[3..5]),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;4,&nbsp;&nbsp;&nbsp;Open&nbsp;8),&nbsp;[5..7])
&nbsp;&nbsp;&nbsp;&nbsp;]
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;allPoints&nbsp;r
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;expected&nbsp;~=?&nbsp;actual</pre>
    </p>
    <p>
        Ultimately, after I'd implemented the <em>next</em> feature, I refactored the <code>allPoints</code> function to make use of it, and it became a simple one-liner:
    </p>
    <p>
        <pre><span style="color:#2b91af;">allPoints</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Enum</span>&nbsp;a,&nbsp;<span style="color:blue;">Num</span>&nbsp;a)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;(<span style="color:blue;">Endpoint</span>&nbsp;a,&nbsp;<span style="color:blue;">Endpoint</span>&nbsp;a)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[a]
allPoints&nbsp;=&nbsp;<span style="color:blue;">uncurry</span>&nbsp;<span style="color:blue;">enumFromTo</span>&nbsp;.&nbsp;endpoints</pre>
    </p>
    <p>
        The <code>allPoints</code> function also enabled me to express the kata's <em>ContainsRange</em> test cases without introducing a new API:
    </p>
    <p>
        <pre><span style="color:#a31515;">&quot;ContainsRange&quot;</span>&nbsp;~:&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;(r,&nbsp;candidate,&nbsp;expected)&nbsp;&lt;-
&nbsp;&nbsp;&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;5),&nbsp;allPoints&nbsp;(Closed&nbsp;7,&nbsp;Open&nbsp;&nbsp;&nbsp;10),&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;5),&nbsp;allPoints&nbsp;(Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;&nbsp;10),&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;3,&nbsp;&nbsp;&nbsp;Open&nbsp;&nbsp;5),&nbsp;allPoints&nbsp;(Closed&nbsp;2,&nbsp;Open&nbsp;&nbsp;&nbsp;10),&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;&nbsp;&nbsp;Open&nbsp;10),&nbsp;allPoints&nbsp;(Closed&nbsp;3,&nbsp;Closed&nbsp;&nbsp;5),&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;3,&nbsp;Closed&nbsp;&nbsp;5),&nbsp;allPoints&nbsp;(Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;&nbsp;&nbsp;5),&nbsp;&nbsp;True)
&nbsp;&nbsp;&nbsp;&nbsp;]
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;r&nbsp;`contains`&nbsp;candidate
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;expected&nbsp;~=?&nbsp;actual</pre>
    </p>
    <p>
        As I've already mentioned, the above implementation of <code>allPoints</code> is based on the next feature, <code>endpoints</code>.
    </p>
    <h3 id="a16cc4c45e614bb9a726c14ef19afc8f">
        Endpoints <a href="#a16cc4c45e614bb9a726c14ef19afc8f">#</a>
    </h3>
    <p>
        The kata also suggests a function to return the two endpoints of a range, as well as some test cases to describe it. Once more, I had to add more test cases to adequately describe the desired functionality:
    </p>
    <p>
        <pre><span style="color:#a31515;">&quot;endPoints&quot;</span>&nbsp;~:&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;(r,&nbsp;expected)&nbsp;&lt;-
&nbsp;&nbsp;&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;&nbsp;&nbsp;Open&nbsp;6),&nbsp;(2,&nbsp;5)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;1,&nbsp;&nbsp;&nbsp;Open&nbsp;7),&nbsp;(1,&nbsp;6)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Closed&nbsp;6),&nbsp;(2,&nbsp;6)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;1,&nbsp;Closed&nbsp;7),&nbsp;(1,&nbsp;7)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;2,&nbsp;&nbsp;&nbsp;Open&nbsp;6),&nbsp;(3,&nbsp;5)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;1,&nbsp;&nbsp;&nbsp;Open&nbsp;7),&nbsp;(2,&nbsp;6)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;2,&nbsp;Closed&nbsp;6),&nbsp;(3,&nbsp;6)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&nbsp;&nbsp;Open&nbsp;1,&nbsp;Closed&nbsp;7),&nbsp;(2,&nbsp;7))
&nbsp;&nbsp;&nbsp;&nbsp;]
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;endpoints&nbsp;r
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;expected&nbsp;~=?&nbsp;actual</pre>
    </p>
    <p>
        The implementation is fairly trivial:
    </p>
    <p>
        <pre><span style="color:#2b91af;">endpoints</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Num</span>&nbsp;a1,&nbsp;<span style="color:blue;">Num</span>&nbsp;a2)&nbsp;<span style="color:blue;">=&gt;</span>&nbsp;(<span style="color:blue;">Endpoint</span>&nbsp;a2,&nbsp;<span style="color:blue;">Endpoint</span>&nbsp;a1)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(a2,&nbsp;a1)
endpoints&nbsp;(Closed&nbsp;x,&nbsp;Closed&nbsp;y)&nbsp;=&nbsp;(x&nbsp;&nbsp;,&nbsp;y)
endpoints&nbsp;(Closed&nbsp;x,&nbsp;&nbsp;&nbsp;Open&nbsp;y)&nbsp;=&nbsp;(x&nbsp;&nbsp;,&nbsp;y-1)
endpoints&nbsp;(&nbsp;&nbsp;Open&nbsp;x,&nbsp;Closed&nbsp;y)&nbsp;=&nbsp;(x+1,&nbsp;y)
endpoints&nbsp;(&nbsp;&nbsp;Open&nbsp;x,&nbsp;&nbsp;&nbsp;Open&nbsp;y)&nbsp;=&nbsp;(x+1,&nbsp;y-1)</pre>
    </p>
    <p>
        One attractive quality of <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a> is that the 'algebra' of the type(s) tell you how many cases you need to pattern-match against. Since I'm treating a range as a pair of <code>Endpoint</code> values, and since each <code>Endpoint</code> can be one of two cases (<code>Open</code> or <code>Closed</code>), there's exactly 2 * 2 = 4 possible combinations (since a tuple is a <a href="https://en.wikipedia.org/wiki/Product_type">product type</a>).
    </p>
    <p>
        That fits with the number of pattern-matches required to implement the function.
    </p>
    <h3 id="c2b611a0c9ba494b9ccc30c5cd3ec4e8">
        Overlapping ranges <a href="#c2b611a0c9ba494b9ccc30c5cd3ec4e8">#</a>
    </h3>
    <p>
        The final interesting feature is a predicate to determine whether one range overlaps another. As has become a refrain by now, I didn't find the suggested test cases sufficient to describe the desired behaviour, so I had to add a few more:
    </p>
    <p>
        <pre><span style="color:#a31515;">&quot;overlapsRange&quot;</span>&nbsp;~:&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;(r,&nbsp;candidate,&nbsp;expected)&nbsp;&lt;-
&nbsp;&nbsp;&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;7,&nbsp;Open&nbsp;10),&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Open&nbsp;10),&nbsp;(Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;3,&nbsp;Open&nbsp;10),&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;2,&nbsp;Open&nbsp;10),&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;1,&nbsp;Open&nbsp;&nbsp;3),&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;5,&nbsp;Open&nbsp;&nbsp;7),&nbsp;False)
&nbsp;&nbsp;&nbsp;&nbsp;]
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;r&nbsp;`overlaps`&nbsp;candidate
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;expected&nbsp;~=?&nbsp;actual</pre>
    </p>
    <p>
        I'm not entirely happy with the implementation:
    </p>
    <p>
        <pre><span style="color:#2b91af;">overlaps</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Ord</span>&nbsp;a1,&nbsp;<span style="color:blue;">Ord</span>&nbsp;a2)&nbsp;<span style="color:blue;">=&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Endpoint&nbsp;a1,&nbsp;Endpoint&nbsp;a2)&nbsp;-&gt;&nbsp;(Endpoint&nbsp;a2,&nbsp;Endpoint&nbsp;a1)&nbsp;-&gt;&nbsp;Bool
overlaps&nbsp;(l1,&nbsp;h1)&nbsp;(l2,&nbsp;h2)&nbsp;=
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;less&nbsp;(Closed&nbsp;x)&nbsp;(Closed&nbsp;y)&nbsp;=&nbsp;x&nbsp;&lt;=&nbsp;y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;less&nbsp;(Closed&nbsp;x)&nbsp;&nbsp;&nbsp;(Open&nbsp;y)&nbsp;=&nbsp;x&nbsp;&lt;&nbsp;&nbsp;y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;less&nbsp;&nbsp;&nbsp;(Open&nbsp;x)&nbsp;(Closed&nbsp;y)&nbsp;=&nbsp;x&nbsp;&lt;&nbsp;&nbsp;y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;less&nbsp;&nbsp;&nbsp;(Open&nbsp;x)&nbsp;&nbsp;&nbsp;(Open&nbsp;y)&nbsp;=&nbsp;x&nbsp;&lt;&nbsp;&nbsp;y
&nbsp;&nbsp;<span style="color:blue;">in</span>&nbsp;l1&nbsp;`less`&nbsp;h2&nbsp;&amp;&amp;&nbsp;l2&nbsp;`less`&nbsp;h1</pre>
    </p>
    <p>
        Noth that the code presented here is problematic in isolation, but if you compare it to the above <code>contains</code> function, there seems to be some repetition going on. Still, it's not <em>quite</em> the same, but the code looks similar enough that it bothers me. I feel that some kind of abstraction is sitting there, right before my nose, mocking me because I can't see it. Still, the code isn't completely duplicated, and even if it was, I can always invoke the <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">rule of three</a> and let it remain as it is.
    </p>
    <p>
        Which is ultimately what I did.
    </p>
    <h3 id="c09e7c817ecc48c097d6660a5438f5e0">
        Equality <a href="#c09e7c817ecc48c097d6660a5438f5e0">#</a>
    </h3>
    <p>
        The kata also suggests some test cases to verify that it's possible to compare two ranges for equality. Dutifully I added those test cases to the code base, even though I knew that they'd automatically pass.
    </p>
    <p>
        <pre><span style="color:#a31515;">&quot;Equals&quot;</span>&nbsp;~:&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;(x,&nbsp;y,&nbsp;expected)&nbsp;&lt;-
&nbsp;&nbsp;&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;&nbsp;True),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Open&nbsp;10),&nbsp;(Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;2,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;3,&nbsp;Open&nbsp;10),&nbsp;False),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((Closed&nbsp;3,&nbsp;Open&nbsp;&nbsp;5),&nbsp;(Closed&nbsp;2,&nbsp;Open&nbsp;10),&nbsp;False)
&nbsp;&nbsp;&nbsp;&nbsp;]
&nbsp;&nbsp;<span style="color:blue;">let</span>&nbsp;actual&nbsp;=&nbsp;x&nbsp;==&nbsp;y
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;$&nbsp;expected&nbsp;~=?&nbsp;actual</pre>
    </p>
    <p>
        In the beginning of this article, I called attention to C#'s regrettable lack of structural equality. Here's an example of what I mean. In Haskell, these tests automatically pass because <code>Endpoint</code> is an <code>Eq</code> instance (by declaration), and all pairs of <code>Eq</code> instances are themselves <code>Eq</code> instances. Simple, elegant, powerful.
    </p>
    <h3 id="094e6dd4c07e40739d6fca4945dc7018">
        Conclusion <a href="#094e6dd4c07e40739d6fca4945dc7018">#</a>
    </h3>
    <p>
        As a first pass at the (admittedly uncomplicated) Range kata, I tried to follow the 'plan' implied by the kata description's test cases. I quickly became frustrated with their lack of completion. They were adequate in indicating to a human (me) what the desired behaviour should be, but insufficient to satisfactorily describe the desired behaviour.
    </p>
    <p>
        I could, of course, have stuck with only those test cases, and instead of employing the Devil's Advocate technique (which I actively tried to avoid) made an honest effort to implement the functionality.
    </p>
    <p>
        The things is, however, that <a href="/2023/03/20/on-trust-in-software-development">I don't trust myself</a>. At its essence, the Range kata is all about edge cases, which are where most bugs tend to lurk. Thus, these are exactly the cases that should be covered by tests.
    </p>
    <p>
        Having made enough 'dumb' programming mistakes during my career, I didn't trust myself to be able to write correct implementations without more test coverage than originally suggested. That's the reason I added more tests.
    </p>
    <p>
        On the other hand, I more than once speculated whether property-based testing would make this work easier. I decided to pursue that idea during my second pass at the kata.
    </p>
    <p>
        <strong>Next:</strong> A Range kata implementation in F#.
    </p>
</div>