---
layout: post
title: "Curb code rot with thresholds"
description: "Code bases deteriorate unless you actively prevent it. Institute some limits that encourage developers to clean up."
date: 2020-04-13 8:43 UTC
tags: [Productivity, Code]
image: "/content/binary/gradual-increase-of-complexity.png"
image_alt: "Line chart showing increasing complexity as time passes."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		From time to time I manage to draw the ire of people, with articles such as <a href="/2019/11/04/the-80-24-rule">The 80/24 rule</a> or <a href="/2019/12/09/put-cyclomatic-complexity-to-good-use">Put cyclomatic complexity to good use</a>. I can understand why. These articles suggest specific constraints to which people should consider consenting. <em>Don't write code wider than 80 characters. Don't write code with a <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a> higher than 7</em>.
	</p>
	<p>
		It makes people uncomfortable.
	</p>
	<h3 id="6c5e4b0817f742bf9ecc0a9050ecb7b5">
		Sophistication <a href="#6c5e4b0817f742bf9ecc0a9050ecb7b5" title="permalink">#</a>
	</h3>
	<p>
		I hope that regular readers understand that I'm a more sophisticated thinker than some of my texts may suggest. I deliberately simplify my points.
	</p>
	<p>
		I do this to make the text more readable. I also aspire to present sufficient arguments, and enough context, that a charitable reader will understand that everything I write should be taken as food for thought rather than gospel.
	</p>
	<p>
		Consider a sentence like the above: <em>I deliberately simplify my points</em>. That sentence, in itself, is an example of deliberate simplification. In reality, I don't <em>always</em> simplify my points. Perhaps sometimes I simplify, but it's not <em>deliberate</em>. I could have written: <em>I often deliberately simplify some of my points</em>. Notice the extra <a href="https://en.wikipedia.org/wiki/Hedge_(linguistics)">hedge words</a>. Imagine an entire text written like that. It would be less readable.
	</p>
	<p>
		I could hedge my words when I write articles, but I don't. I believe that a text that states its points as clearly as possible is easier to understand for any careful reader. I also believe that hedging my language will not prevent casual readers from misunderstanding what I had in mind.
	</p>
	<h3 id="a5da32d0580d4a0f8c19069c57c2a335">
		Archetypes <a href="#a5da32d0580d4a0f8c19069c57c2a335" title="permalink">#</a>
	</h3>	
	<p>
		Why do I suggest hard limits on line width, cyclomatic complexity, and so on?
	</p>
	<p>
		In light of the above, realise that the limits I offer are suggestions. A number like 80 characters isn't a hard limit. It's a representation of an idea; a token. The same is true for <a href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two">the magic number seven, plus or minus two</a>. That too, represents an idea - the idea that human short-term memory is limited, and that this impacts our ability to read and understand code.
	</p>
	<p>
		The number seven serves as an archetype. It's a proxy for a more complex idea. It's a simplification that, hopefully, makes it easier to follow the plot.
	</p>
	<p>
		<em>Each method should have a maximum cyclomatic complexity of seven.</em> That's easier to understand than <em>each method should have a maximum cyclomatic complexity small enough that it fits within the cognitive limits of the human brain's short-term memory</em>.
	</p>
	<p>
		I've noticed that a subset of the developer population is quite literal-minded. If I declare: <em>don't write code wider than 80 characters</em> they're happy if they agree, and infuriated if they don't.
	</p>
	<p>
		If you've been paying attention, you now understand that this isn't about the number <em>80</em>, or <em>24</em>, or <em>7</em>. It's about instituting useful quantitative guidance. The actual number is less important.
	</p>
	<p>
		I have reasons to prefer those specific values. I've already motivated them in previous articles. I'm not, though, obdurately attached to those particular numbers. I'd rather work with a team that has agreed to a 120-character maximum width than with a team that follows no policy.
	</p>
	<h3 id="8b7d0a456f6f4bdca9ea2814a67144fc">
		How code rots <a href="#8b7d0a456f6f4bdca9ea2814a67144fc" title="permalink">#</a>
	</h3>
	<p>
		No-one deliberately decides to write legacy code. Code bases gradually deteriorate.
	</p>
	<p>
		Here's another deliberate simplification: code gradually becomes more complicated because each change seems small, and no-one pays attention to the overall quality. It doesn't happen overnight, but one day you realise that you've developed a legacy code base. When that happens, it's too late to do anything about it.
	</p>
	<p>
		<img src="/content/binary/gradual-increase-of-complexity.png" alt="Line chart showing increasing complexity as time passes.">
	</p>
	<p>
		At the beginning, a method has low complexity, but as you fix defects and add features, the complexity increases. If you don't pay attention to cyclomatic complexity, you pass <em>7</em> without noticing it. You pass <em>10</em> without noticing it. You pass <em>15</em> and <em>20</em> without noticing it.
	</p>
	<p>
		One day you discover that you have a problem - not because you finally look at a metric, but because the code has now become so complicated that everyone notices. Alas, now it's too late to do anything about it.
	</p>
	<p>
		<a href="https://en.wikipedia.org/wiki/Software_rot">Code rot</a> sets in a little at a time; it works likeÂ <a href="https://en.wikipedia.org/wiki/Boiling_frog">boiling the proverbial frog</a>.
	</p>
	<h3 id="4fd818d9459548a7863f38ebdd6c40f8">
		Thresholds <a href="#4fd818d9459548a7863f38ebdd6c40f8" title="permalink">#</a>
	</h3>
	<p>
		Agreeing on a threshold can help curb code rot. Institute a rule and monitor a metric. For example, you could agree to keep an eye on cyclomatic complexity. If it exceeds <em>7</em>, you reject the change.
	</p>
	<p>
		<img src="/content/binary/development-of-complexity-guarded-by-threshold.png" alt="Line chart showing how complexity is curbed by a threshold of 7.">
	</p>
	<p>
		Such rules work because they can be used to counteract gradual decay. It's not the specific value <em>7</em> that contributes to better <a href="/2019/03/04/code-quality-is-not-software-quality">code quality</a>; it's the automatic activation of a rule based on a threshold. If you decide that the threshold should be <em>10</em> instead, that'll also make a difference.
	</p>
	<p>
		Notice that the above diagram suggests that exceeding the threshold is still possible. Rules are in the way if you must rigidly obey them. Situations arise where breaking a rule is the best response. Once you've responded to the situation, however, find a way to bring the offending code back in line. Once a threshold is exceeded, you don't get any further warnings, and there's a risk that that particular code will gradually decay.
	</p>
	<h3 id="431b3a30bb6448b6b34c06a169b6fefb">
		What you measure is what you get <a href="#431b3a30bb6448b6b34c06a169b6fefb" title="permalink">#</a>
	</h3>
	<p>
		You could automate the process. Imagine running cyclomatic complexity analysis as part of a Continuous Integration build and rejecting changes that exceed a threshold. This is, in a way, a deliberate attempt to hack the management effect where you get what you measure. With emphasis on a metric like cyclomatic complexity, developers will pay attention to it.
	</p>
	<p>
		Be aware, however, of <a href="https://en.wikipedia.org/wiki/Goodhart%27s_law">Goodhart's law</a> and <a href="https://en.wikipedia.org/wiki/Unintended_consequences">the law of unintended consequences</a>. Just as <a href="/2015/11/16/code-coverage-is-a-useless-target-measure">code coverage is a useless target measure</a>, you have to be careful when you institute hard rules.
	</p>
	<p>
		I've had success with introducing threshold rules because they increase awareness. It can help a technical leader shift emphasis to the qualities that he or she wishes to improve. Once the team's mindset has changed, the rule itself becomes redundant.
	</p>
	<p>
		I'm reminded of <a href="https://en.wikipedia.org/wiki/Dreyfus_model_of_skill_acquisition">the Dreyfus model of skill acquisition</a>. Rules make great training wheels. Once you become proficient, the rules are no longer required. They may even be in your way. When that happens, get rid of them.
	</p>
	<h3 id="97ad7bcd44644a05b78c75e82a3c4ad7">
		Conclusion <a href="#97ad7bcd44644a05b78c75e82a3c4ad7" title="permalink">#</a>
	</h3>
	<p>
		Code deteriorates gradually, when you aren't looking. Instituting rules that make you pay attention can combat code rot. Using thresholds to activate your attention can be an effective countermeasure. The specific value of the threshold is less important.
	</p>
	<p>
		In this article, I've mostly used cyclomatic complexity as an example of a metric where a threshold could be useful. Another example is line width; don't exceed 80 characters. Or line height: methods shouldn't exceed 24 lines of code. Those are examples. If you agree that keeping an eye on a metric would be useful, but you disagree with the threshold I suggest, pick a value that suits you better.
	</p>
	<p>
		It's not the specific threshold value that improves your code; paying attention does.
	</p>
</div>
<div id="comments">
	<hr>
	<h2 id="comments-header">
		Comments
	</h2>
	<div class="comment" id="f50c5f69f3ed45d4a1fd1a0d4099f079">
		<div class="comment-author"><a href="https://www.relativisticramblings.com/">Christer van der Meeren</a></div>
		<div class="comment-content">
			<p>In F#, it's not uncommon to have inner functions (local functions defined inside other functions). How would you calculate the cyclomatic complexity of a function that contains inner functions?</p>
		<p>To be specific, I'm actually wondering about how to count the number of activated objects in a function, which you talk about in your book, <em>Code That Fits in Your Head</em>. I have been wanting to ask you this for some time, but haven't been able to find a good article to comment on. I think this is the closest I can get.</p>
		<p>In terms of activated objects: Would you count all activated objects in all sub-functions as counting towards the top-level function? Or would you count the inner functions separately, and have calls to the inner function contribute only "one point" to the top-level functions? I think the latter makes most sense, but I'm not sure. I base my reasoning on the fact that an inner function, being a closure, is similar to a class with fields and a single method (<a href="http://wiki.c2.com/?ClosuresAndObjectsAreEquivalent">closures are a poor man's objects and vice versa</a>). Another way to view it is that you could refactor by extracting the function and adding any necessary parameters.</p>
		<p>PS, this is not just theoretical. I am toying with a linter for F# and want "number of activated objects" as one of the rules.</p>
		</div>
		<div class="comment-date">2023-04-20 14:00 UTC</div>
	</div>

	<div class="comment" id="bfdeb86dcefc457ab84cbd0b42bfcdd0">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				Christer, thank you for writing. For the purposes of calculating cyclomatic complexity of inner functions, aren't they equivalent to (private) helper methods?
			</p>
			<p>
				If so, they don't count towards the cyclomatic complexity of the containing function.
			</p>
			<p>
				As for the other question, I don't count functions as activated objects, but I do count the values they return. When the function is <a href="https://en.wikipedia.org/wiki/Referential_transparency">referentially transparent</a>, however, they're equal. I do talk more about this in my talk <em>Fractal Architecture</em>, of which you can find several recordings on the internet; <a href="https://youtu.be/mRbTMlE5ElA">here</a>'s one.
			</p>
			<p>
				The book also discusses this, and that part is also <a href="/2021/07/28/referential-transparency-fits-in-your-head">freely available here on the blog</a>.
			</p>
			<p>
				The short answer is that it's essential that you can prevent 'inner' objects from leaking out from method calls. Per definition, functions that are referentially transparent do have that property. For methods that aren't referentially transparent, encapsulation may still achieve the same effect, if done right. Usually, however, it isn't.
			</p>
		</div>
		<div class="comment-date">2023-04-21 16:26 UTC</div>
	</div>
	
	<div class="comment" id="ad61d353f8614a059c36d497de796b8d">
		<div class="comment-author"><a href="https://www.relativisticramblings.com/">Christer van der Meeren</a></div>
		<div class="comment-content">
			<p>Mark, thank you for the response. What you say about cyclomatic complexity makes sense, especially given your previous writings on the subject. I am still a bit fuzzy on how to count activated objects, though.</p>
			<p>If a function returns a tuple of which one item is ignored, would that ignored object count as an activated object? (Does the fact that a tuple could technically be considered as a single object with <code>.Item1</code> and <code>.Item2</code> properties change the answer?) And what about piping? Eta reduction?</p>
			<p><a href="http://www.exampler.com/">An example would be handy right about now</a>, so what would you say are the activated object counts of the following functionally identical functions, and why?<p>
			<ol>
				<li><code>let f (a, b) = let c, _ = getCD (a, b) in c</code></li>
				<li><code>let f (a, b) = (a, b) |> getCD |> fst</code></li>
				<li><code>let f = getCD >> fst</code></li>
				<li><code>let f = getCDFst</code></li>
			</ol>
			<p>Note the "trick" of number 3: By removing the explicit parameter, it is now impossible to tell just from looking at the code how many tupled items <code>f</code> accepts, if any. And in number 4, even the knowledge that an intermediate function in the composition returns a tuple of 2 values is removed.</p>
			<p>Additionally: I assume that returning a value counts as "activating" an object? So <code>let f x = x</code> has 1 activated object? What about the functionally identical <code>let f = id</code>? Would that be 1 or 0?</p>
			<p>I guess what I'm after is a more fully developed concept of "the number of activated objects" of a function/method, to the point where a useful linter rule could be implemented based on it; something similar to your previous writings on how <a href="https://blog.ploeh.dk/2019/12/09/put-cyclomatic-complexity-to-good-use/#de927bfcc95d410bbfcd0adf7a63926b">method calls do not increase the cyclomatic complexity</a>, which was a very useful clarification that I have seen you repeat several times. I have given the matter some thought myself, but as you can see, I haven't been able to come up with good answer.</p>
		</div>
		<div class="comment-date">2023-04-22 06:03 UTC</div>
	</div>

	<div class="comment" id="313c192fff9d4748bfafb8d8997e47dc">
		<div class="comment-author"><a href="{{ HOME_PATH }}">Mark Seemann</a></div>
		<div class="comment-content">
			<p>
				It seems that I should have been more explicit about the terminology related to the adjective <em>activated</em>. I was inspired by the notion of object activation described in <a href="/ref/thinking-fast-and-slow">Thinking Fast and Slow</a>. The idea is that certain pieces of information move to the forefront in the mind, and that these 'objects' impact decision-making. Kahneman labels such information as <em>activated</em> when it impacts the decision process.
			</p>
			<p>
				The heuristic I had in mind was to port that idea to an (informal) readability analysis. Given that the human short-time memory is quite limited, I find it useful to count the mental load of a given piece of code.
			</p>
			<p>
				The point, then, is not to count all objects or values in scope, but rather those that are required to understand what a piece of code does. For example, if you look at an instance method on a class, the class could have four class fields, but if only one of those fields are used in the method, only that one is activated - even though the other three are also in scope.
			</p>
			<p>
				With that in mind, let's try to look at your four examples.
			</p>
			<ol>
				<li>This example activates <code>a</code>, <code>b</code>, and <code>c</code>: <em>3</em> objects.</li>
				<li>This example activates <code>a</code> and <code>b</code>: <em>2</em> objects.</li>
				<li>No objects, unless you now want to count <code>getCD</code> as an object.</li>
				<li>Again, probably no objects.</li>
			</ol>
			<p>
				Note that I've employed qualifying words. The point of the analysis is to highlight objects that might stress our short-term memory. It's not an exact science, and I never intended it to be. Rather, I see it as a possible springboard for having a discussion about relative readability of code. A team can use the heuristic to compare alternatives.
			</p>
			<p>
				With your examples in mind, you'd be likely to run into programmers who find the first two examples more readable than the third. It's certainly more 'detailed', so, in a sense, it's easier to understand what's going on. That works as long as you only have a few values in play, but cognitively, it doesn't scale.
			</p>
			<p>
				I do tend to prefer eta reductions and point-free notation exactly because they tend to reduce the number of activated objects, but these techniques certainly also raise the abstraction level. On the other hand, once someone understands something like function composition (<code>&gt;&gt;</code>) or point-free notation, they can now leverage long-term memory for that, instead of having to rely on limited short-term memory in order to understand a piece of code. By moving more information to long-term memory, we can reduce the load on short-term memory, thereby freeing it up for other information.
			</p>
			<p>
				Perhaps that's a bit of a digression, but I always intended the notion of object activation to be a heuristic rather than an algorithm.
			</p>
		</div>
		<div class="comment-date">2023-04-23 20:01 UTC</div>
	</div>
	
	<div class="comment" id="66b5e9838a4a42eda1108eb2338a0fe5">
		<div class="comment-author"><a href="https://www.relativisticramblings.com/">Christer van der Meeren</a></div>
		<div class="comment-content">
			<p>Mark, thank you for the excellent clarification. It gave me one of those "a-ha" moments that accompanies a sudden jump in understanding. In hindsight, of course this is about the cognitive load of a piece of code, and of course that will be different for different people, based for example on which abstractions they are used to.</p>
			<p>In terms of the code examples, I think we both agree that <code>let f = a >> b</code> requires less mental load than <code>let f = a >> b >> c >> d >> e</code>. In other words, I would argue that functions in a composition do contribute to cognitive load. This may however also depend on the actual functions that are composed.</p>
			<p>In any case, I am now less certain than before that a simple linter rule (i.e., an algorithm) can capture cognitive load in a way that is generally useful. I will have to think about this some more.</p>
		</div>
		<div class="comment-date">2023-04-22 06:03 UTC</div>
	</div>
</div>
